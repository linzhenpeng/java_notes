# Tree

[数据结构 - 树](https://www.jianshu.com/p/45661b029292)

[总结深度优先与广度优先的区别](https://blog.csdn.net/u010412301/article/details/79949730)

[数据结构中各种树](https://www.cnblogs.com/maybe2030/p/4732377.html)

## 树基本概念

树是一种数据结构，它看上去像一棵 "圣诞树"，它的根在上，叶朝下。

**树有多个节点(node)，用以储存元素。某些节点之间存在一定的关系，用连线表示，连线称为边(edge)。边的上端节点称为父节点，下端称为子节点。树像是一个不断分叉的树根。**

例如：

![](./images/树/1630488-8dc158fa0d630829.webp)



树要吗为空树(empty tree)，要吗具有以下特性：

1. 每个节点可以有多个子节点(children)，而该节点是相应子节点的父节点(parent) - 比如说，1,2 是 0 的子节点，3 是 7,8 的父节点
2. 树有一个没有父节点的节点，称为根节点(root) - 比如图中的 0 节点
3. 没有子节点的节点称为叶节点(leaf) - 比如图中的 7，8，9，10 节点
4. 两个具有相同父节点的节点称为兄弟节点(sibling) - 比如图中 4，5 节点互为兄弟节点
5. 一个节点的子节点以及子节点的后代称为该节点的子树 (subtree) - 比如 1 和 1 的子节点构成了节点 0 的一棵子树

树的深度和高度的定义:

- **深度**：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0(从根到n)；
- **高度**：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0(从n到叶子)；

其它概念:

1. **节点的度**：一个节点含有的子树的个数称为该节点的度；
2. **树的度**：一棵树中，最大的节点的度称为树的度；
3. **叶节点**或**终端节点**：度为零的节点；
4. **非终端节点**或**分支节点**：度不为零的节点；
5. **父亲节点**或**父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点；
6. **孩子节点**或**子节点**：一个节点含有的子树的根节点称为该节点的子节点；
7. **兄弟节点**：具有相同父节点的节点互称为兄弟节点；
8. 节点的**层次**：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
9. **深度**：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
10. **高度**：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
11. **堂兄弟节点**：父节点在同一层的节点互为堂兄弟；
12. **节点的祖先**：从根到该节点所经分支上的所有节点；
13. **子孙**：以某节点为根的子树中任一节点都称为该节点的子孙。
14. **森林**：由m（m>=0）棵互不相交的树的集合称为森林；



## 二叉树

**首先，二叉树(binary)是一种特殊的树，它是每个节点最多有两个子树的树结构，通常子树被称作是 "左子树" 和 "右子树"，二叉树常用于实现二叉搜索树和二叉堆。(这些在后面都会介绍)**

例如: 下面这个就是一棵二叉树

![](./images/树/1630488-d31341fa4aca7ce7.webp)

常见的二叉树有：完全二叉树，满二叉树，二叉搜索树，二叉堆，AVL 树，红黑树，哈夫曼树。这些都会在后面一一介绍。

## 满二叉树

很好理解，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树被称之为满二叉树。

**满二叉树一定是完全二叉树，完全二叉树不一定满二叉树。**

例如：

![](./images/树/1630488-d87b70e0df31dc74.webp)

一个高度为 h 的满二叉树含有 `1 + 2 + 4 + ... + 2^h = 2^(h + 1) - 1个节点`，所以满二叉树的节点个数一定为奇数。

## 完全二叉树

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

例如:

![](./images/树/1630488-79802447d1d63c9b.webp)

**即除了最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。**而像这样就不是完全二叉树.

用途：

完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高。后面介绍的二叉堆也是基于完全二叉树来实现的。



## 二叉查找树

**二叉搜索树是一种特殊的二叉树，也可以称为二叉排序树，二叉查找树。**除了具有二叉树的基本性质外，它还具备：

1. 树中每个节点最多有两个子树，通常称为左子树和右子树
2. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
3. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
4. 它的左右子树仍然是一棵二叉搜索树 (recursive)

例图：

![](./images/树/1630488-60da433cfb7b6a03.webp)

**二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图中的“9”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。**

　　**二叉查找树的高度决定了二叉查找树的查找效率。**



#### 基本类型:

```java
class TreeNode<E extends Comparable<E>> {
	private E data;
	private TreeNode<E> left;
	private TreeNode<E> right;
	TreeNode(E theData) {
		data = theData;
		left = null;
		right = null;
	}
	public E getData() {return data;}
	public void setData(E data) {this.data = data;}
	public TreeNode<E> getLeft() {return left;}
	public void setLeft(TreeNode<E> left) {this.left = left;}
	public TreeNode<E> getRight() {return right;}
	public void setRight(TreeNode<E> right) {this.right = right;}
}
public class BinarySearchTree<E extends Comparable<E>>{
    private TreeNode<E> root = null;
}
```

#### 树的遍历

树遍历有**深度优先**和**广度优先**两种方式:

1, **深度优先遍历(DFS)**：对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。要特别注意的是，二叉树的深度优先遍历比较特殊，可以细分为先序遍历、中序遍历、后序遍历。具体说明如下：

- 先序遍历：对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。
- 中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。
- 后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。

2,**广度优先遍历(BFS)**：又叫层次遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。　　

3, 二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列。

4,深度优先搜索算法：不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。

广度优先搜索算法：保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。

​          通常 深度优先搜索法不全部保留结点，扩展完的结点从数据库中弹出删去，这样，一般在数据库中存储的结点数就是深度值，因此它占用空间较少。

所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。 　

​          广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。

但广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些

##### 深度优先算法实现:

**1. 前序遍历：当到达某个节点时，先输出该节点，再访问左子节点，最后访问右子节点。**

代码实现：

```java
    /**
     * 前序遍历(递归)
     * @param cursor
     */
    public void preOrder(TreeNode<E> cursor){
        if(cursor == null) return;
        System.out.println(cursor.getData());
        preOrder(cursor.getLeft());
        preOrder(cursor.getRight());
    }
    /**
     * 前序遍历 非递归版
     * @param root
     */
    public void preOrderNoRec(TreeNode<E> root) {
    	LinkedList<TreeNode<E>> stack=new LinkedList<>();
    	stack.push(root);
    	TreeNode<E> currentNode=null;
    	while(!stack.isEmpty()) {
    		currentNode=stack.pop();
    		System.out.println(currentNode.getData());
    		if(currentNode.getRight()!=null)
    			stack.push(currentNode.getRight());
    		if(currentNode.getLeft()!=null)
    			stack.push(currentNode.getLeft());
    	}
    }
```
**2.中序遍历：当到达某个节点时，先访问左子节点，再输出该节点，最后访问右子节点。**

代码实现:

```java
    /**
     * 中序遍历(递归)
     * @param cursor
     */
    public void inOrder(TreeNode<E> cursor){
        if(cursor == null) return;
        inOrder(cursor.getLeft());
        System.out.println(cursor.getData());
        inOrder(cursor.getRight());
    }
    /**中序遍历 非递归版
     * @param root
     */
	public void inOrderNoRec(TreeNode<E> root) {
		LinkedList<TreeNode<E>> stack = new LinkedList<>();
		TreeNode<E> currentNode = root;
		while (currentNode != null || !stack.isEmpty()) {
			while (currentNode != null) {
				stack.push(currentNode);
				currentNode = currentNode.getLeft();
			}
			currentNode = stack.pop();
			System.out.println(currentNode.getData());
			currentNode = currentNode.getRight();
		}
	}
```



**3. 后序遍历：当到达某个节点时，先访问左子节点，再访问右子节点，最后输出该节点。**

代码实现：

```java
    /**
     * 后序遍历(递归)
     * @param cursor
     */
    public void postOrder(TreeNode<E> cursor){
        if(cursor == null) return;
        postOrder(cursor.getLeft());
        postOrder(cursor.getRight());
        System.out.println(cursor.getData());
    }

	/**后序遍历 非递归版
	 * @param root
	 */
	public void postOrderNoRec(TreeNode<E> root) {
		LinkedList<TreeNode<E>> stack = new LinkedList<>();
		TreeNode<E> currentNode = root;
		TreeNode<E> rightNode = null;
		
		while (currentNode != null || !stack.isEmpty()) {
              // 一直循环到二叉排序树最左端的叶子结点（currentNode是null）
			while (currentNode != null) {
				stack.push(currentNode);
				currentNode = currentNode.getLeft();
			}
			currentNode = stack.pop();
            // 当前结点没有右结点或上一个结点（已经输出的结点）是当前结点的右结点，则输出当前结点 
			while (currentNode.getRight() == null || currentNode.getRight() == rightNode) {
				System.out.println(currentNode.getData());
				rightNode = currentNode;
				if (stack.isEmpty())//root以输出，则遍历结束  
					return;
				currentNode = stack.pop();
			}
			 stack.push(currentNode); //还有右结点没有遍历  
	         currentNode = currentNode.getRight();
		}
	}
```

##### 广度优先算法实现:

```java
    /** 
     * 广度优先遍历二叉树，又称层次遍历二叉树 
     * @param node 
     */ 
	public void breadthFirstTraverse(TreeNode<E> root) {
		Queue<TreeNode<E>> queue = new LinkedList<>();
		TreeNode<E> currentNode = root;
		queue.offer(currentNode);
		while (!queue.isEmpty()) {
			currentNode = queue.poll();
			System.out.println(currentNode.getData());
			if (currentNode.getLeft() != null)
				queue.offer(currentNode.getLeft());
			if (currentNode.getRight() != null)
				queue.offer(currentNode.getRight());
		}
	}
	
```

#### 节点插入

步骤：

1. 递归地去查找该二叉树，找到应该插入的节点
2. 若当前的二叉查找树为空，则插入的元素为根节点
3. 若插入的元素值小于根节点值，则将元素插入到左子树中
4. 若插入的元素值不小于根节点值，则将元素插入到右子树中

```java
public void insertNode(TreeNode<E> node) {
		TreeNode<E> currentNode = root;
		if (currentNode == null) {
			root = node;
			return;
		} else {
			while (true) {
				if (node.getData().compareTo(currentNode.getData()) < 0) {
					if (currentNode.getLeft() == null) {
						break;
					} else {
						currentNode = currentNode.getLeft();
					}
				} else if (node.getData().compareTo(currentNode.getData()) > 0) {

					if (currentNode.getRight() == null) {
						break;
					} else {
						currentNode = currentNode.getRight();
					}
				}
			}
		}
		if (node.getData().compareTo(currentNode.getData()) < 0) {
			currentNode.setLeft(node);
		} else if (node.getData().compareTo(currentNode.getData()) > 0) {
			currentNode.setRight(node);
		}
	}
```

#### 节点删除

首先需要搜索该节点，然后可以分为以下四种情况进行讨论：

**1.如果找不到该节点，那么什么都不用做**

例如：要在树中删除元素 22

![](./images/树/1630488-9a36f1b007b72502.webp)

**2.如果被移除的元素在叶节点(no children)：那么直接移除该节点，并且将父节点原本指向该位置改为 null (如果是根节点，那就不用修改父节点指向位置)**

例如：要在树中删除元素 6

![](./images/树/1630488-b4670854b1fed172.webp)

**3.如果删除的元素只有一个儿子(one child)：那么也很简单，直接删除该节点，并且将父节点原本指向的位置改为该儿子 (如果是根节点，那么该儿子成为新的根节点)**

例如：要在树中删除元素 20

![](./images/树/1630488-0eb4fc709c1316d4.webp)

**4.如果删除的元素有两个儿子，那么可以取左子树中最大元素或者右子树中最小元素进行替换，然后将最大元素最小元素原位置置空**

例如：要在树中删除元素 15

![](./images/树/1630488-606b485509ba620b.webp)



## 平衡二叉树

二叉搜索树虽然在插入和删除时的效率都有所提升，但是如果二叉树变成了下图：

![](F:\git\java_notes\images\树\1630488-14d4db6560c2868d.webp)



二叉树快退化成链表，那么搜索效率效率就会变得很低,时间复杂度由 logn 退化到 n，这时候我们需要添加一些额外的条件来约束它，使其可以保持具有 logn 的时间复杂度。

首先平衡树得是二叉树，它满足二叉树的所有性质。

**判定是否为平衡树的条件：将该树重新排序，若不存在重新排序后的二叉树的树高比原来的树小，则判定该树为平衡树。**

比如:

![](F:\git\java_notes\images\树\1630488-0e598902adf02a2e.webp)

这里有棵树高度为 2，那么我们知道高度为 1 的树最多只有三个节点，五个节点是无法构成一棵高度为 1 的二叉树，故上图的二叉树是平衡树。

又比如：

​	![](F:\git\java_notes\images\树\1630488-a6ce9032ad0f4d7e.webp)

该树高度为 3，我们知道一棵高度为 2 的树最多可以有 `2^(h + 1) - 1 = 7`(**满二叉树**)的节点，故图上的的树只有五个节点，那么它经过重新调整之后可以变为一个高度为 2 的二叉树，故不符合平衡树的性质，故该树不是平衡树。

由上我们可以得出一个结论：

1. 如果一棵树是平衡的，那么它所满足的节点数 n 需要满足 `2^h - 1 < n <= 2^(h + 1) - 1` 
2. 插入和删除一个节点的时间复杂度均为: O(logn)
3. 这里虽然有一些算法可以使平衡二叉树 - 但是它们并没什么卵用，因为我们一般都是在添加或删除操作时候来去平衡树，而不是再一开始去平衡树。

## 平衡查找树之AVL树

**AVL树定义：**AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 "An algorithm for the organization of information" 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。**这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。**

**AVL树的自平衡操作——旋转：**

　　AVL树最关键的也是最难的一步操作就是**旋转**。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。

　　对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：

![](F:\git\java_notes\images\树\2012082016021366.jpg)

　　1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。

　　2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。

　　3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。

　　4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。

从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。

**单旋转**

　　单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。

![](F:\git\java_notes\images\树\avltree35.jpg)

为使树恢复平衡，我们把k1变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。

　　这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。

　　**双旋转**

　　对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。  

![](F:\git\java_notes\images\树\2012082016534455.jpg)

为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。

代码实现

```python
import java.util.Comparator;
public class AvlTree<AnyType extends Comparable<? super AnyType>> {
	private AvlNode<AnyType> root;
	private Comparator<? super AnyType> cmp;

	/********* AVL树节点数据结构定义 **********/
	private static class AvlNode<AnyType> {
		AnyType element;
		AvlNode<AnyType> left;
		AvlNode<AnyType> right;
		int height;

		AvlNode(AnyType theElement) {
			this(theElement, null, null);
		}

		AvlNode(AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt) {
			element = theElement;
			left = lt;
			right = rt;
			height = 0;
		}
	}

	public AvlTree() {
		root = null;
	}

	public void makeEmpty() {
		root = null;
	}

	public boolean isEmpty() {
		return root == null;
	}

	public void insert(AnyType element) {
		root = insert(element, root);
	}

	public boolean contains(AnyType x) {
		return contains(x, root);
	}

	public void remove(AnyType element) {
		root = remove(element, root);
	}

	private int myCompare(AnyType lhs, AnyType rhs) {
		if (cmp != null)
			return cmp.compare(lhs, rhs);
		else
			return ((Comparable) lhs).compareTo(rhs);
	}

	private boolean contains(AnyType x, AvlNode<AnyType> t) {
		// 空树处理
		if (t == null)
			return false;
		// 正常情况处理
		// @方式一：对Comparable型的对象进行比较
		// int compareResult = x.compareTo(t.element);
		// @方式二：使用一个函数对象而不是要求这些项是Comparable的
		int compareResult = myCompare(x, t.element);
		if (compareResult < 0)
			return contains(x, t.left);
		else if (compareResult > 0)
			return contains(x, t.right);
		else
			return true;
	}

	private int height(AvlNode<AnyType> t) {
		return t == null ? -1 : t.height;
	}

	private AvlNode<AnyType> findMin(AvlNode<AnyType> t) {
		if (t == null)
			return null;
		if (t.left == null)
			return t;
		return findMin(t.left);
	}

	private AvlNode<AnyType> findMax(AvlNode<AnyType> t) {
		if (t == null)
			return null;
		if (t.right == null)
			return t;
		return findMax(t.right);
	}

	private AvlNode<AnyType> insert(AnyType x, AvlNode<AnyType> t) {
		if (t == null)
			return new AvlNode<AnyType>(x, null, null);
		int compareResult = myCompare(x, t.element);
		if (compareResult < 0) {
			t.left = insert(x, t.left);
			if (height(t.left) - height(t.right) == 2) {
				if (myCompare(x, t.left.element) < 0) // 左左情况
					t = rotateWithLeftChild(t);
				else // 左右情况
					t = doubleWithLeftChild(t);
			}
		} else if (compareResult > 0) {
			t.right = insert(x, t.right);
			if (height(t.right) - height(t.left) == 2) {
				if (myCompare(x, t.right.element) < 0) // 右左情况
					t = doubleWithRightChild(t);
				else // 右右情况
					t = rotateWithRightChild(t);
			}
		}
		// 完了之后更新height值
		t.height = Math.max(height(t.left), height(t.right)) + 1;
		return t;
	}

	private AvlNode<AnyType> remove(AnyType x, AvlNode<AnyType> t) {
		if (t == null)
			return null;
		int compareResult = myCompare(x, t.element);
		if (compareResult < 0) {
			t.left = remove(x, t.left);
			// 完了之后验证该子树是否平衡
			if (t.right != null) { // 若右子树为空，则一定是平衡的，此时左子树相当对父节点深度最多为1, 所以只考虑右子树非空情况
				if (t.left == null) { // 若左子树删除后为空，则需要判断右子树
					if (height(t.right) - t.height == 2) {
						AvlNode<AnyType> k = t.right;
						if (k.right != null) { // 右子树存在，按正常情况单旋转
							System.out.println(
									"-----------------------------------------------------------------------------11111");
							t = rotateWithRightChild(t);
						} else { // 否则是右左情况，双旋转
							System.out.println(
									"-----------------------------------------------------------------------------22222");
							t = doubleWithRightChild(t);
						}
					}
				} else { // 否则判断左右子树的高度差
					// 左子树自身也可能不平衡，故先平衡左子树，再考虑整体
					AvlNode<AnyType> k = t.left;
					// 删除操作默认用右子树上最小节点补删除的节点
					// k的左子树高度不低于k的右子树
					if (k.right != null) {
						if (height(k.left) - height(k.right) == 2) {
							AvlNode<AnyType> m = k.left;
							if (m.left != null) { // 左子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------33333");
								k = rotateWithLeftChild(k);
							} else { // 否则是左右情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------44444");
								k = doubleWithLeftChild(k);
							}
						}
					} else {
						if (height(k.left) - k.height == 2) {
							AvlNode<AnyType> m = k.left;
							if (m.left != null) { // 左子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------hhhhh");
								k = rotateWithLeftChild(k);
							} else { // 否则是左右情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------iiiii");
								k = doubleWithLeftChild(k);
							}
						}
					}
					if (height(t.right) - height(t.left) == 2) {
						// 右子树自身一定是平衡的，左右失衡的话单旋转可以解决问题
						System.out.println(
								"-----------------------------------------------------------------------------55555");
						t = rotateWithRightChild(t);
					}
				}
			}
			// 完了之后更新height值
			t.height = Math.max(height(t.left), height(t.right)) + 1;
		} else if (compareResult > 0) {
			t.right = remove(x, t.right);
			// 下面验证子树是否平衡
			if (t.left != null) { // 若左子树为空，则一定是平衡的，此时右子树相当对父节点深度最多为1
				if (t.right == null) { // 若右子树删除后为空，则只需判断左子树
					if (height(t.left) - t.height == 2) {
						AvlNode<AnyType> k = t.left;
						if (k.left != null) {
							System.out.println(
									"-----------------------------------------------------------------------------66666");
							t = rotateWithLeftChild(t);
						} else {
							System.out.println(
									"-----------------------------------------------------------------------------77777");
							t = doubleWithLeftChild(t);
						}
					}
				} else { // 若右子树删除后非空，则判断左右子树的高度差
					// 右子树自身也可能不平衡，故先平衡右子树，再考虑整体
					AvlNode<AnyType> k = t.right;
					// 删除操作默认用右子树上最小节点（靠左）补删除的节点
					// k的右子树高度不低于k的左子树
					if (k.left != null) {
						if (height(k.right) - height(k.left) == 2) {
							AvlNode<AnyType> m = k.right;
							if (m.right != null) { // 右子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------88888");
								k = rotateWithRightChild(k);
							} else { // 否则是右左情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------99999");
								k = doubleWithRightChild(k);
							}
						}
					} else {
						if (height(k.right) - k.height == 2) {
							AvlNode<AnyType> m = k.right;
							if (m.right != null) { // 右子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------aaaaa");
								k = rotateWithRightChild(k);
							} else { // 否则是右左情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------bbbbb");
								k = doubleWithRightChild(k);
							}
						}
					}
					if (height(t.left) - height(t.right) == 2) {
						// 左子树自身一定是平衡的，左右失衡的话单旋转可以解决问题
						System.out.println(
								"-----------------------------------------------------------------------------ccccc");
						t = rotateWithLeftChild(t);
					}
				}
			}
			// 完了之后更新height值
			t.height = Math.max(height(t.left), height(t.right)) + 1;
		} else if (t.left != null && t.right != null) {
			// 默认用其右子树的最小数据代替该节点的数据并递归的删除那个节点
			t.element = findMin(t.right).element;
			t.right = remove(t.element, t.right);
			if (t.right == null) { // 若右子树删除后为空，则只需判断左子树与根的高度差
				if (height(t.left) - t.height == 2) {
					AvlNode<AnyType> k = t.left;
					if (k.left != null) {
						System.out.println(
								"-----------------------------------------------------------------------------ddddd");
						t = rotateWithLeftChild(t);
					} else {
						System.out.println(
								"-----------------------------------------------------------------------------eeeee");
						t = doubleWithLeftChild(t);
					}
				}
			} else { // 若右子树删除后非空，则判断左右子树的高度差
				// 右子树自身也可能不平衡，故先平衡右子树，再考虑整体
				AvlNode<AnyType> k = t.right;
				// 删除操作默认用右子树上最小节点（靠左）补删除的节点

				if (k.left != null) {
					if (height(k.right) - height(k.left) == 2) {
						AvlNode<AnyType> m = k.right;
						if (m.right != null) { // 右子树存在，按正常情况单旋转
							System.out.println(
									"-----------------------------------------------------------------------------fffff");
							k = rotateWithRightChild(k);
						} else { // 否则是右左情况，双旋转
							System.out.println(
									"-----------------------------------------------------------------------------ggggg");
							k = doubleWithRightChild(k);
						}
					}
				} else {
					if (height(k.right) - k.height == 2) {
						AvlNode<AnyType> m = k.right;
						if (m.right != null) { // 右子树存在，按正常情况单旋转
							System.out.println(
									"-----------------------------------------------------------------------------hhhhh");
							k = rotateWithRightChild(k);
						} else { // 否则是右左情况，双旋转
							System.out.println(
									"-----------------------------------------------------------------------------iiiii");
							k = doubleWithRightChild(k);
						}
					}
				}
				// 左子树自身一定是平衡的，左右失衡的话单旋转可以解决问题
				if (height(t.left) - height(t.right) == 2) {
					System.out.println(
							"-----------------------------------------------------------------------------jjjjj");
					t = rotateWithLeftChild(t);
				}
			}
			// 完了之后更新height值
			t.height = Math.max(height(t.left), height(t.right)) + 1;
		} else {
			System.out.println("-----------------------------------------------------------------------------kkkkk");
			t = (t.left != null) ? t.left : t.right;
		}
		return t;
	}

	// 左左情况单旋转
	private AvlNode<AnyType> rotateWithLeftChild(AvlNode<AnyType> k2) {
		AvlNode<AnyType> k1 = k2.left;
		k2.left = k1.right;
		k1.right = k2;
		k2.height = Math.max(height(k2.left), height(k2.right)) + 1;
		k1.height = Math.max(height(k1.left), k2.height) + 1;
		return k1; // 返回新的根
	}

	// 右右情况单旋转
	private AvlNode<AnyType> rotateWithRightChild(AvlNode<AnyType> k2) {
		AvlNode<AnyType> k1 = k2.right;
		k2.right = k1.left;
		k1.left = k2;
		k2.height = Math.max(height(k2.left), height(k2.right)) + 1;
		k1.height = Math.max(height(k1.right), k2.height) + 1;
		return k1; // 返回新的根
	}

	// 左右情况
	private AvlNode<AnyType> doubleWithLeftChild(AvlNode<AnyType> k3) {
		try {
			k3.left = rotateWithRightChild(k3.left);
		} catch (NullPointerException e) {
			System.out.println("k.left.right为：" + k3.left.right);
			throw e;
		}
		return rotateWithLeftChild(k3);
	}

	// 右左情况
	private AvlNode<AnyType> doubleWithRightChild(AvlNode<AnyType> k3) {
		try {
			k3.right = rotateWithLeftChild(k3.right);
		} catch (NullPointerException e) {
			System.out.println("k.right.left为：" + k3.right.left);
			throw e;
		}
		return rotateWithRightChild(k3);
	}
}




```

测试样例

```java
import java.util.Random;
import org.junit.Test;

public class AvlTreeTest {
	private AvlTree<Integer> avlTree = new AvlTree<Integer>();

	@Test
	public void testInsert() {
		avlTree.insert(100);
		avlTree.insert(120);
		avlTree.insert(300);
		avlTree.insert(500);
		avlTree.insert(111);
		avlTree.insert(92);
		avlTree.insert(77);
		avlTree.insert(125);
		System.out.println(avlTree.contains(120));
		avlTree.remove(120);
		avlTree.remove(125); // 需要单旋转
		System.out.println(avlTree.contains(120));
		avlTree.insert(78); // 需要双旋转
		System.out.println("Insert Success !");
	}

	@Test
	public void testRotate() {
		avlTree.insert(100);
		avlTree.insert(90);
		avlTree.insert(92);
		avlTree.insert(78);
		avlTree.insert(76);
		System.out.println("Insert Success !");
	}

	/**
	 * 通过较大数据进行测试，暂时还没有发现问题
	 */
	@Test
	public void testAll() {
		avlTree.makeEmpty();
		Random random = new Random();
		for (int i = 1; i <= 1000000; i++) {
			avlTree.insert(random.nextInt(1000000));
		}
		for (int i = 2000000; i >= 1000000; i--) {
			avlTree.insert(i);
		}
		/*
		 * for(int i=700000;i>=400000;i--){ avlTree.insert(i); } for(int
		 * i=100000;i<=200000;i++){ avlTree.insert(i); } for(int
		 * i=400000;i<=500000;i++){ avlTree.insert(random.nextInt(600000)); }
		 */
		for (int i = 200000; i < 1400000; i++) {
			int target = random.nextInt(1500000);
			if (avlTree.contains(target)) {
				avlTree.remove(target);
			}
		}
		System.out.println("Insert Success !");
	}
}
```

## 平衡查找树之红黑树

[红黑树(一)之 原理和算法详细介绍](https://www.cnblogs.com/skywang12345/p/3245399.html)

[红黑树(五)之 Java的实现](https://www.cnblogs.com/skywang12345/p/3624343.html)

[教你初步了解红黑树](https://blog.csdn.net/v_JULY_v/article/details/6105630)

[史上最清晰的红黑树讲解（上）](https://www.cnblogs.com/CarpenterLee/p/5503882.html)

#### 红黑树的定义

红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为”对称二叉B树”，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。**它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。**

红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。

 R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

**红黑树的特性**:
**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

**注意**：
(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

红黑树示意图如下：

![](F:\git\java_notes\images\树\251730074203156.jpg)

红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。
例如，Java集合中的[TreeSet](http://www.cnblogs.com/skywang12345/p/3311268.html)和[TreeMap](http://www.cnblogs.com/skywang12345/p/3310928.html),HashMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。



#### 树的旋转知识

当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。

1,左旋

![](F:\git\java_notes\images\树\8394323_1293614183gD0H.jpg)

如上图所示，当在某个结点pivot上，做左旋操作时，我们假设它的右孩子y不是NIL[T]，pivot可以为任何不是NIL[T]的左子结点。左旋以pivot到Y之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的左孩子b则成为pivot的右孩子。

```java
LeftRoate(T, x)
y ← x.right				       //定义y：y是x的右孩子
x.right ← y.left	            //y的左孩子成为x的右孩子
if y.left ≠ T.nil
    y.left.p ← x	
y.p ← x.p				       //x的父结点成为y的父结点
if x.p = T.nil
	then T.root ← y
else if x = x.p.left
	then x.p.left ← y
else x.p.right ← y 
y.left ← x                       //x作为y的左孩子
x.p ← y
```

2,右旋

![](F:\git\java_notes\images\树\8394323_1293614183DSC3.jpg)

树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。

#### **红黑树的插入**

要真正理解红黑树的插入，还得先理解二叉查找树的插入。磨刀不误砍柴工，咱们再来了解一下二叉查找树的插入和红黑树的插入。

如果要在二叉查找树中插入一个结点，首先要查找到结点要插入的位置，然后进行插入。假设插入的结点为z的话，插入的伪代码如下：

```java
TREE-INSERT(T, z)
y ← NIL
x ← T.root
while x ≠ NIL
	do y ←  x
	if z.key < x.key
		then x ← x.left
	else x ← x.right
z.p ← y
if y == NIL
	then T.root ← z       
else if z.key < y.key
	then y.left ← z
else y.right ← z
```

**红黑树的插入和插入修复**

现在我们了解了二叉查找树的插入，接下来，咱们便来具体了解下红黑树的插入操作。红黑树的插入相当于在二叉查找树插入的基础上，为了重新恢复平衡，继续做了插入修复操作。

假设插入的结点为z，红黑树的插入伪代码具体如下所示：

```java
RB-INSERT(T, z)
y ← nil
x ← T.root
while x ≠ T.nil
	do y ← x
	if z.key < x.key
		then x ← x.left
	else x ← x.right
z.p ← y
if y == nil[T]
	then T.root ← z
else if z.key < y.key
	then y.left ← z
else y.right ← z
z.left ← T.nil
z.right ← T.nil
z.color ← RED
RB-INSERT-FIXUP(T, z)
```

把上面这段红黑树的插入代码，跟之前看到的二叉查找树的插入代码比较一下可以看出，RB-INSERT(T, z)前面的第1～13行代码基本上就是二叉查找树的插入代码，然后第14～16行代码把z的左孩子和右孩子都赋为叶结点nil，再把z结点着为红色，最后为保证红黑性质在插入操作后依然保持，调用一个辅助程序RB-INSERT-FIXUP来对结点进行重新着色，并旋转。

换言之，如果插入的是根结点，由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色；如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。

但当遇到下述3种情况时又该如何调整呢？

● 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色

● 插入修复情况2：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子

● 插入修复情况3：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左子

答案就是根据红黑树插入代码RB-INSERT(T, z)最后一行调用的RB-INSERT-FIXUP(T, z)函数所示的步骤进行操作，具体如下所示：

```java
RB-INSERT-FIXUP(T, z)
while z.p.color == RED// 若“当前节点(z)的父节点是红色”，则进行以下处理。
	do if z.p == z.p.p.left// 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。
		then y ← z.p.p.right // 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”
		if y.color == RED // Case 1条件：叔叔是红色
			then z.p.color ← BLACK   ▹ Case 1//  (01) 将“父节点”设为黑色。
			     y.color ← BLACK     ▹ Case 1//  (02) 将“叔叔节点”设为黑色。
			     z.p.p.color ← RED   ▹ Case 1//  (03) 将“祖父节点”设为“红色”。
			     z ← z.p.p           ▹ Case 1//  (04) 将“祖父节点”设为“当前节点”(红色节点)
		else if z == z.p.right // Case 2条件：叔叔是黑色，且当前节点是右孩子
			then z ← z.p             ▹ Case 2 //  (01) 将“父节点”作为“新的当前节点”。
			     LEFT-ROTATE(T, z)   ▹ Case 2//  (02) 以“新的当前节点”为支点进行左旋。
		z.p.color ← BLACK             ▹ Case 3// Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。
		z.p.p.color ← RED             ▹ Case 3//  (02) 将“祖父节点”设为“红色”。
		RIGHT-ROTATE(T, z.p.p)        ▹ Case 3//  (03) 以“祖父节点”为支点进行右旋。
	else (same as then clause with "right" and "left" exchanged)// 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。
T.root.color ← BLACK
```

下面，咱们来分别处理上述3种插入修复情况。

- **插入修复情况1：当前结点的父结点是红色，祖父结点的另一个子结点（叔叔结点）是红色。**

如下代码所示：

```java
while z.p.color == RED
	do if z.p == z.p.p.left
		then y ← z.p.p.right
		if y.color == RED
```

此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。这里只考虑父结点为祖父左孩子的情况，如下图所示（勘误：图中15节点应改为13，特此说明，下同）：

![](F:\git\java_notes\images\树\8394323_129361793372ZK.png)



对此，我们的解决策略是：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。即如下代码所示：

```java
			then z.p.color ← BLACK               ▹ Case 1
			y.color ← BLACK                    ▹ Case 1
			z.p.p.color ← RED                    ▹ Case 1
			z ← z.p.p                            ▹ Case 1
```

所以，变化后如下图所示：

![](F:\git\java_notes\images\树\8394323_1293617934U9zr.png)

于是，插入修复情况1转换成了插入修复情况2。

- **插入修复情况2：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子**

此时，解决对策是：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。即如下代码所示：

```java
		else if z == z.p.right
			then z ← z.p                          ▹ Case 2
			LEFT-ROTATE(T, z)                   ▹ Case 2
```

所以红黑树变为

![](F:\git\java_notes\images\树\8394323_1293617934d11j.png)

从而插入修复情况2转换成了插入修复情况3。

- **插入修复情况3：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左孩子**

解决对策是：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，操作代码为：

```java
		z.p.color ← BLACK                        ▹ Case 3
		z.p.p.color ← RED                         ▹ Case 3
		RIGHT-ROTATE(T, z.p.p)                  ▹ Case 3
```

最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。所以红黑树由之前的：

![](F:\git\java_notes\images\树\8394323_1293617935EaES.png)



「回顾：经过上面情况3、情况4、情况5等3种插入修复情况的操作示意图，读者自会发现，后面的情况4、情况5都是针对情况3插入节点4以后，进行的一系列插入修复情况操作，不过，指向当前节点N指针一直在变化。所以，你可以想当然的认为：整个下来，情况3、4、5就是一个完整的插入修复情况的操作流程」

#### 红黑树的删除

接下来，咱们最后来了解，红黑树的删除操作。

"我们删除的节点的方法与常规二叉搜索树中删除节点的方法是一样的，如果被删除的节点不是有双非空子女，则直接删除这个节点，用它的唯一子节点顶替它的位置，如果它的子节点分是空节点，那就用空节点顶替它的位置，如果它的双子全为非空，我们就把它的直接后继节点内容复制到它的位置，之后以同样的方式删除它的后继节点，它的后继节点不可能是双子非空，因此此传递过程最多只进行一次。”

二叉查找树的删除
继续讲解之前，补充说明下二叉树结点删除的几种情况，待删除的节点按照儿子的个数可以分为三种：

1,没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。
2,只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。
3,有两个儿子。这是最麻烦的情况，因为你删除节点之后，还要保证满足搜索二叉树的结构。其实也比较容易，我们可以选择左儿子中的最大元素或者右儿子中的最小元素放到待删除节点的位置，就可以保证结构的不变。当然，你要记得调整子树，毕竟又出现了节点删除。习惯上大家选择左儿子中的最大元素，其实选择右儿子的最小元素也一样，没有任何差别，只是人们习惯从左向右。这里咱们也选择左儿子的最大元素，将它放到待删结点的位置。左儿子的最大元素其实很好找，只要顺着左儿子不断的去搜索右子树就可以了，直到找到一个没有右子树的结点。那就是最大的了。
二叉查找树的删除代码如下所示：

```java
TREE-DELETE(T, z)
if left[z] = nil[T] or right[z] = nil[T]         
   then y ← z                        // 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；
   else y ← TREE-SUCCESSOR(z)        // 否则，将“z的后继节点”赋值给 “y”.左边最大或右边最小节点
if left[y] ≠ nil[T]
   then x ← left[y]                   // 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；
   else x ← right[y]                   // 否则，“y的右孩子” 赋值给 “x”。
p[x] ← p[y]                            // 将“y的父节点” 设置为 “x的父节点”
if p[y] = nil[T]                               
   then root[T] ← x                    // 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。
   else if y = left[p[y]]                    
           then left[p[y]] ← x  // 情况2若“y是它父节点的左孩子”则设置“x” 为 “y的父节点的左孩子”
           else right[p[y]] ← x // 情况3若“y是它父节点的右孩子”则设置“x” 为 “y的父节点的右孩子”
if y ≠ z                                    
   then key[z] ← key[y]   // 若“y的值” 赋值给 “z”。
        copy y's satellite data into z         
return y
```

#### 红黑树的删除和删除修复

OK，回到红黑树上来，红黑树结点删除的算法实现是：

RB-DELETE(T, z) 单纯删除结点的总操作

```java
1 if left[z] = nil[T] or right[z] = nil[T]  
 2    then y ← z  
 3    else y ← TREE-SUCCESSOR(z)  
 4 if left[y] ≠ nil[T]  
 5    then x ← left[y]  
 6    else x ← right[y]  
 7 p[x] ← p[y]  
 8 if p[y] = nil[T]  
 9    then root[T] ← x  
10    else if y = left[p[y]]  
11            then left[p[y]] ← x  
12            else right[p[y]] ← x  
13 if y ≠ z  
14    then key[z] ← key[y]  
15         copy y's satellite data into z  
16 if color[y] = BLACK  
17    then RB-DELETE-FIXUP(T, x)  
18 return y
```

“在删除节点后，原红黑树的性质可能被改变，如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质5被破坏。如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质4被破坏。如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质2。”

RB-DELETE-FIXUP(T, x) 恢复与保持红黑性质的工作

```java
 1 while x ≠ root[T] and color[x] = BLACK  
 2     do if x = left[p[x]]  
 3           then w ← right[p[x]]  
 4                if color[w] = RED  
 5                   then color[w] ← BLACK                        ▹  Case 1  
 6                        color[p[x]] ← RED                       ▹  Case 1  
 7                        LEFT-ROTATE(T, p[x])                    ▹  Case 1  
 8                        w ← right[p[x]]                         ▹  Case 1  
 9                if color[left[w]] = BLACK and color[right[w]] = BLACK  
10                   then color[w] ← RED                          ▹  Case 2  
11                        x ← p[x]                                ▹  Case 2  
12                   else if color[right[w]] = BLACK  
13                           then color[left[w]] ← BLACK          ▹  Case 3  
14                                color[w] ← RED                  ▹  Case 3  
15                                RIGHT-ROTATE(T, w)              ▹  Case 3  
16                                w ← right[p[x]]                 ▹  Case 3  
17                         color[w] ← color[p[x]]                 ▹  Case 4  
18                         color[p[x]] ← BLACK                    ▹  Case 4  
19                         color[right[w]] ← BLACK                ▹  Case 4  
20                         LEFT-ROTATE(T, p[x])                   ▹  Case 4  
21                         x ← root[T]                            ▹  Case 4  
22        else (same as then clause with "right" and "left" exchanged)  
23 color[x] ← BLACK 
```

“上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。"--saturnman。

如果是以下情况，恢复比较简单：

a)当前节点是红+黑色
解法，直接把当前节点染成黑色，结束此时红黑树性质全部恢复。
b)当前节点是黑+黑且是根节点， 解法：什么都不做，结束。
但如果是以下情况呢？：

删除修复情况1：当前节点是黑+黑且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)
删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色
删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色
删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意
此时，我们需要调用RB-DELETE-FIXUP(T, x)，来恢复与保持红黑性质的工作。

下面，咱们便来分别处理这4种删除修复情况。

删除修复情况1：当前节点是黑(原颜色)+黑(删除颜色)且兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。

解法：把父节点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟节点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟节点为黑色的情况)。 即如下代码操作：

```java
//调用RB-DELETE-FIXUP(T, x) 的1-8行代码
 1 while x ≠ root[T] and color[x] = BLACK
 2     do if x = left[p[x]]
 3           then w ← right[p[x]]
 4                if color[w] = RED
 5                   then color[w] ← BLACK                        ▹  Case 1
 6                        color[p[x]] ← RED                       ▹  Case 1
 7                        LEFT-ROTATE(T, p[x])                    ▹  Case 1
 8                        w ← right[p[x]]                         ▹  Case 1
```

变化前:

![](F:\git\java_notes\images\树\8394323_1293639256A48Q.jpg)

变化后

![](F:\git\java_notes\images\树\8394323_1293639257Le09.jpg)

**删除修复情况2：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色。**

解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。（此变换后性质5不变），即调用RB-INSERT-FIXUP(T, z) 的第9-10行代码操作，如下：

```java
//调用RB-DELETE-FIXUP(T, x) 的9-11行代码
9                if color[left[w]] = BLACK and color[right[w]] = BLACK
10                   then color[w] ← RED                          ▹  Case 2
11                        x p[x]                                  ▹  Case 2

```

变化前

![](F:\git\java_notes\images\树\8394323_1293639257n0vx.jpg)

变化后

![](F:\git\java_notes\images\树\8394323_1293639257AEGX.jpg)

删除修复情况3：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色。

解法：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持，即调用RB-INSERT-FIXUP(T, z) 的第12-16行代码，如下所示：

```java
//调用RB-DELETE-FIXUP(T, x) 的第12-16行代码
12                   else if color[right[w]] = BLACK
13                           then color[left[w]] ← BLACK          ▹  Case 3
14                                color[w] ← RED                  ▹  Case 3
15                                RIGHT-ROTATE(T, w)              ▹  Case 3
16                                w ← right[p[x]]                 ▹  Case 3
```

变化前:

![](F:\git\java_notes\images\树\8394323_1293639257NxGG.jpg)

变化后:

![](F:\git\java_notes\images\树\8394323_1293639258kVkZ.jpg)

删除修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。

解法：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确，即调用RB-INSERT-FIXUP(T, z)的第17-21行代码，如下所示：

```java
//调用RB-DELETE-FIXUP(T, x) 的第17-21行代码
17                         color[w] ← color[p[x]]                 ▹  Case 4
18                         color[p[x]] ← BLACK                    ▹  Case 4
19                         color[right[w]] ← BLACK                ▹  Case 4
20                         LEFT-ROTATE(T, p[x])                   ▹  Case 4
21                         x ← root[T]                            ▹  Case 4
```

变化前:

![](F:\git\java_notes\images\树\8394323_12936392583Plc.jpg)

变化后:

![](F:\git\java_notes\images\树\8394323_12936392580xKm.jpg)

最后值得一提的是**上述删除修复的情况1~4都只是树的局部，并非树的整体全部，且删除修复情况3、4在经过上面的调整后，调整还没结束**（还得继续调整直至重新恢复平衡，只是图并没有画出来）。



## B,B+,B*树

## LSM树

## Trie树

## 哈夫曼树

## KD树

