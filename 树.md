# Tree

[数据结构 - 树](https://www.jianshu.com/p/45661b029292)

[总结深度优先与广度优先的区别](https://blog.csdn.net/u010412301/article/details/79949730)

[数据结构中各种树](https://www.cnblogs.com/maybe2030/p/4732377.html)

## 树基本概念

树是一种数据结构，它看上去像一棵 "圣诞树"，它的根在上，叶朝下。

**树有多个节点(node)，用以储存元素。某些节点之间存在一定的关系，用连线表示，连线称为边(edge)。边的上端节点称为父节点，下端称为子节点。树像是一个不断分叉的树根。**

例如：

![](./images/树/1630488-8dc158fa0d630829.webp)



树要吗为空树(empty tree)，要吗具有以下特性：

1. 每个节点可以有多个子节点(children)，而该节点是相应子节点的父节点(parent) - 比如说，1,2 是 0 的子节点，3 是 7,8 的父节点
2. 树有一个没有父节点的节点，称为根节点(root) - 比如图中的 0 节点
3. 没有子节点的节点称为叶节点(leaf) - 比如图中的 7，8，9，10 节点
4. 两个具有相同父节点的节点称为兄弟节点(sibling) - 比如图中 4，5 节点互为兄弟节点
5. 一个节点的子节点以及子节点的后代称为该节点的子树 (subtree) - 比如 1 和 1 的子节点构成了节点 0 的一棵子树

树的深度和高度的定义:

- **深度**：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0(从根到n)；
- **高度**：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0(从n到叶子)；

其它概念:

1. **节点的度**：一个节点含有的子树的个数称为该节点的度；
2. **树的度**：一棵树中，最大的节点的度称为树的度；
3. **叶节点**或**终端节点**：度为零的节点；
4. **非终端节点**或**分支节点**：度不为零的节点；
5. **父亲节点**或**父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点；
6. **孩子节点**或**子节点**：一个节点含有的子树的根节点称为该节点的子节点；
7. **兄弟节点**：具有相同父节点的节点互称为兄弟节点；
8. 节点的**层次**：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
9. **深度**：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
10. **高度**：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
11. **堂兄弟节点**：父节点在同一层的节点互为堂兄弟；
12. **节点的祖先**：从根到该节点所经分支上的所有节点；
13. **子孙**：以某节点为根的子树中任一节点都称为该节点的子孙。
14. **森林**：由m（m>=0）棵互不相交的树的集合称为森林；



## 二叉树

**首先，二叉树(binary)是一种特殊的树，它是每个节点最多有两个子树的树结构，通常子树被称作是 "左子树" 和 "右子树"，二叉树常用于实现二叉搜索树和二叉堆。(这些在后面都会介绍)**

例如: 下面这个就是一棵二叉树

![](./images/树/1630488-d31341fa4aca7ce7.webp)

常见的二叉树有：完全二叉树，满二叉树，二叉搜索树，二叉堆，AVL 树，红黑树，哈夫曼树。这些都会在后面一一介绍。

## 满二叉树

很好理解，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树被称之为满二叉树。

**满二叉树一定是完全二叉树，完全二叉树不一定满二叉树。**

例如：

![](./images/树/1630488-d87b70e0df31dc74.webp)

一个高度为 h 的满二叉树含有 `1 + 2 + 4 + ... + 2^h = 2^(h + 1) - 1个节点`，所以满二叉树的节点个数一定为奇数。

## 完全二叉树

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

例如:

![](./images/树/1630488-79802447d1d63c9b.webp)

**即除了最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。**而像这样就不是完全二叉树.

用途：

完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高。后面介绍的二叉堆也是基于完全二叉树来实现的。



## 二叉查找树

**二叉搜索树是一种特殊的二叉树，也可以称为二叉排序树，二叉查找树。**除了具有二叉树的基本性质外，它还具备：

1. 树中每个节点最多有两个子树，通常称为左子树和右子树
2. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
3. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
4. 它的左右子树仍然是一棵二叉搜索树 (recursive)

例图：

![](./images/树/1630488-60da433cfb7b6a03.webp)

**二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图中的“9”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。**

　　**二叉查找树的高度决定了二叉查找树的查找效率。**



#### 基本类型:

```java
class TreeNode<E extends Comparable<E>> {
	private E data;
	private TreeNode<E> left;
	private TreeNode<E> right;
	TreeNode(E theData) {
		data = theData;
		left = null;
		right = null;
	}
	public E getData() {return data;}
	public void setData(E data) {this.data = data;}
	public TreeNode<E> getLeft() {return left;}
	public void setLeft(TreeNode<E> left) {this.left = left;}
	public TreeNode<E> getRight() {return right;}
	public void setRight(TreeNode<E> right) {this.right = right;}
}
public class BinarySearchTree<E extends Comparable<E>>{
    private TreeNode<E> root = null;
}
```

#### 树的遍历

树遍历有**深度优先**和**广度优先**两种方式:

1, **深度优先遍历(DFS)**：对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。要特别注意的是，二叉树的深度优先遍历比较特殊，可以细分为先序遍历、中序遍历、后序遍历。具体说明如下：

- 先序遍历：对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。
- 中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。
- 后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。

2,**广度优先遍历(BFS)**：又叫层次遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。　　

3, 二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列。

4,深度优先搜索算法：不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。

广度优先搜索算法：保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。

​          通常 深度优先搜索法不全部保留结点，扩展完的结点从数据库中弹出删去，这样，一般在数据库中存储的结点数就是深度值，因此它占用空间较少。

所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。 　

​          广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。

但广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些

##### 深度优先算法实现:

**1. 前序遍历：当到达某个节点时，先输出该节点，再访问左子节点，最后访问右子节点。**

代码实现：

```java
    /**
     * 前序遍历(递归)
     * @param cursor
     */
    public void preOrder(TreeNode<E> cursor){
        if(cursor == null) return;
        System.out.println(cursor.getData());
        preOrder(cursor.getLeft());
        preOrder(cursor.getRight());
    }
    /**
     * 前序遍历 非递归版
     * @param root
     */
    public void preOrderNoRec(TreeNode<E> root) {
    	LinkedList<TreeNode<E>> stack=new LinkedList<>();
    	stack.push(root);
    	TreeNode<E> currentNode=null;
    	while(!stack.isEmpty()) {
    		currentNode=stack.pop();
    		System.out.println(currentNode.getData());
    		if(currentNode.getRight()!=null)
    			stack.push(currentNode.getRight());
    		if(currentNode.getLeft()!=null)
    			stack.push(currentNode.getLeft());
    	}
    }
```
**2.中序遍历：当到达某个节点时，先访问左子节点，再输出该节点，最后访问右子节点。**

代码实现:

```java
    /**
     * 中序遍历(递归)
     * @param cursor
     */
    public void inOrder(TreeNode<E> cursor){
        if(cursor == null) return;
        inOrder(cursor.getLeft());
        System.out.println(cursor.getData());
        inOrder(cursor.getRight());
    }
    /**中序遍历 非递归版
     * @param root
     */
	public void inOrderNoRec(TreeNode<E> root) {
		LinkedList<TreeNode<E>> stack = new LinkedList<>();
		TreeNode<E> currentNode = root;
		while (currentNode != null || !stack.isEmpty()) {
			while (currentNode != null) {
				stack.push(currentNode);
				currentNode = currentNode.getLeft();
			}
			currentNode = stack.pop();
			System.out.println(currentNode.getData());
			currentNode = currentNode.getRight();
		}
	}
```



**3. 后序遍历：当到达某个节点时，先访问左子节点，再访问右子节点，最后输出该节点。**

代码实现：

```java
    /**
     * 后序遍历(递归)
     * @param cursor
     */
    public void postOrder(TreeNode<E> cursor){
        if(cursor == null) return;
        postOrder(cursor.getLeft());
        postOrder(cursor.getRight());
        System.out.println(cursor.getData());
    }

	/**后序遍历 非递归版
	 * @param root
	 */
	public void postOrderNoRec(TreeNode<E> root) {
		LinkedList<TreeNode<E>> stack = new LinkedList<>();
		TreeNode<E> currentNode = root;
		TreeNode<E> rightNode = null;
		
		while (currentNode != null || !stack.isEmpty()) {
              // 一直循环到二叉排序树最左端的叶子结点（currentNode是null）
			while (currentNode != null) {
				stack.push(currentNode);
				currentNode = currentNode.getLeft();
			}
			currentNode = stack.pop();
            // 当前结点没有右结点或上一个结点（已经输出的结点）是当前结点的右结点，则输出当前结点 
			while (currentNode.getRight() == null || currentNode.getRight() == rightNode) {
				System.out.println(currentNode.getData());
				rightNode = currentNode;
				if (stack.isEmpty())//root以输出，则遍历结束  
					return;
				currentNode = stack.pop();
			}
			 stack.push(currentNode); //还有右结点没有遍历  
	         currentNode = currentNode.getRight();
		}
	}
```

##### 广度优先算法实现:

```java
    /** 
     * 广度优先遍历二叉树，又称层次遍历二叉树 
     * @param node 
     */ 
	public void breadthFirstTraverse(TreeNode<E> root) {
		Queue<TreeNode<E>> queue = new LinkedList<>();
		TreeNode<E> currentNode = root;
		queue.offer(currentNode);
		while (!queue.isEmpty()) {
			currentNode = queue.poll();
			System.out.println(currentNode.getData());
			if (currentNode.getLeft() != null)
				queue.offer(currentNode.getLeft());
			if (currentNode.getRight() != null)
				queue.offer(currentNode.getRight());
		}
	}
	
```

#### 节点插入

步骤：

1. 递归地去查找该二叉树，找到应该插入的节点
2. 若当前的二叉查找树为空，则插入的元素为根节点
3. 若插入的元素值小于根节点值，则将元素插入到左子树中
4. 若插入的元素值不小于根节点值，则将元素插入到右子树中

```java
public void insertNode(TreeNode<E> node) {
		TreeNode<E> currentNode = root;
		if (currentNode == null) {
			root = node;
			return;
		} else {
			while (true) {
				if (node.getData().compareTo(currentNode.getData()) < 0) {
					if (currentNode.getLeft() == null) {
						break;
					} else {
						currentNode = currentNode.getLeft();
					}
				} else if (node.getData().compareTo(currentNode.getData()) > 0) {

					if (currentNode.getRight() == null) {
						break;
					} else {
						currentNode = currentNode.getRight();
					}
				}
			}
		}
		if (node.getData().compareTo(currentNode.getData()) < 0) {
			currentNode.setLeft(node);
		} else if (node.getData().compareTo(currentNode.getData()) > 0) {
			currentNode.setRight(node);
		}
	}
```

#### 节点删除

首先需要搜索该节点，然后可以分为以下四种情况进行讨论：

**1.如果找不到该节点，那么什么都不用做**

例如：要在树中删除元素 22

![](./images/树/1630488-9a36f1b007b72502.webp)

**2.如果被移除的元素在叶节点(no children)：那么直接移除该节点，并且将父节点原本指向该位置改为 null (如果是根节点，那就不用修改父节点指向位置)**

例如：要在树中删除元素 6

![](./images/树/1630488-b4670854b1fed172.webp)

**3.如果删除的元素只有一个儿子(one child)：那么也很简单，直接删除该节点，并且将父节点原本指向的位置改为该儿子 (如果是根节点，那么该儿子成为新的根节点)**

例如：要在树中删除元素 20

![](./images/树/1630488-0eb4fc709c1316d4.webp)

**4.如果删除的元素有两个儿子，那么可以取左子树中最大元素或者右子树中最小元素进行替换，然后将最大元素最小元素原位置置空**

例如：要在树中删除元素 15

![](./images/树/1630488-606b485509ba620b.webp)



## 平衡二叉树

二叉搜索树虽然在插入和删除时的效率都有所提升，但是如果二叉树变成了下图：

![](F:\git\java_notes\images\树\1630488-14d4db6560c2868d.webp)



二叉树快退化成链表，那么搜索效率效率就会变得很低,时间复杂度由 logn 退化到 n，这时候我们需要添加一些额外的条件来约束它，使其可以保持具有 logn 的时间复杂度。

首先平衡树得是二叉树，它满足二叉树的所有性质。

**判定是否为平衡树的条件：将该树重新排序，若不存在重新排序后的二叉树的树高比原来的树小，则判定该树为平衡树。**

比如:

![](F:\git\java_notes\images\树\1630488-0e598902adf02a2e.webp)

这里有棵树高度为 2，那么我们知道高度为 1 的树最多只有三个节点，五个节点是无法构成一棵高度为 1 的二叉树，故上图的二叉树是平衡树。

又比如：

​	![](F:\git\java_notes\images\树\1630488-a6ce9032ad0f4d7e.webp)

该树高度为 3，我们知道一棵高度为 2 的树最多可以有 `2^(h + 1) - 1 = 7`(**满二叉树**)的节点，故图上的的树只有五个节点，那么它经过重新调整之后可以变为一个高度为 2 的二叉树，故不符合平衡树的性质，故该树不是平衡树。

由上我们可以得出一个结论：

1. 如果一棵树是平衡的，那么它所满足的节点数 n 需要满足 `2^h - 1 < n <= 2^(h + 1) - 1` 
2. 插入和删除一个节点的时间复杂度均为: O(logn)
3. 这里虽然有一些算法可以使平衡二叉树 - 但是它们并没什么卵用，因为我们一般都是在添加或删除操作时候来去平衡树，而不是再一开始去平衡树。

## 平衡查找树之AVL树

**AVL树定义：**AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 "An algorithm for the organization of information" 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。**这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。**

**AVL树的自平衡操作——旋转：**

　　AVL树最关键的也是最难的一步操作就是**旋转**。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。

　　对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：

![](F:\git\java_notes\images\树\2012082016021366.jpg)

　　1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。

　　2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。

　　3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。

　　4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。

从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。

**单旋转**

　　单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。

![](F:\git\java_notes\images\树\avltree35.jpg)

为使树恢复平衡，我们把k1变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。

　　这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。

　　**双旋转**

　　对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。  

![](F:\git\java_notes\images\树\2012082016534455.jpg)

为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。

代码实现

```python
import java.util.Comparator;
public class AvlTree<AnyType extends Comparable<? super AnyType>> {
	private AvlNode<AnyType> root;
	private Comparator<? super AnyType> cmp;

	/********* AVL树节点数据结构定义 **********/
	private static class AvlNode<AnyType> {
		AnyType element;
		AvlNode<AnyType> left;
		AvlNode<AnyType> right;
		int height;

		AvlNode(AnyType theElement) {
			this(theElement, null, null);
		}

		AvlNode(AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt) {
			element = theElement;
			left = lt;
			right = rt;
			height = 0;
		}
	}

	public AvlTree() {
		root = null;
	}

	public void makeEmpty() {
		root = null;
	}

	public boolean isEmpty() {
		return root == null;
	}

	public void insert(AnyType element) {
		root = insert(element, root);
	}

	public boolean contains(AnyType x) {
		return contains(x, root);
	}

	public void remove(AnyType element) {
		root = remove(element, root);
	}

	private int myCompare(AnyType lhs, AnyType rhs) {
		if (cmp != null)
			return cmp.compare(lhs, rhs);
		else
			return ((Comparable) lhs).compareTo(rhs);
	}

	private boolean contains(AnyType x, AvlNode<AnyType> t) {
		// 空树处理
		if (t == null)
			return false;
		// 正常情况处理
		// @方式一：对Comparable型的对象进行比较
		// int compareResult = x.compareTo(t.element);
		// @方式二：使用一个函数对象而不是要求这些项是Comparable的
		int compareResult = myCompare(x, t.element);
		if (compareResult < 0)
			return contains(x, t.left);
		else if (compareResult > 0)
			return contains(x, t.right);
		else
			return true;
	}

	private int height(AvlNode<AnyType> t) {
		return t == null ? -1 : t.height;
	}

	private AvlNode<AnyType> findMin(AvlNode<AnyType> t) {
		if (t == null)
			return null;
		if (t.left == null)
			return t;
		return findMin(t.left);
	}

	private AvlNode<AnyType> findMax(AvlNode<AnyType> t) {
		if (t == null)
			return null;
		if (t.right == null)
			return t;
		return findMax(t.right);
	}

	private AvlNode<AnyType> insert(AnyType x, AvlNode<AnyType> t) {
		if (t == null)
			return new AvlNode<AnyType>(x, null, null);
		int compareResult = myCompare(x, t.element);
		if (compareResult < 0) {
			t.left = insert(x, t.left);
			if (height(t.left) - height(t.right) == 2) {
				if (myCompare(x, t.left.element) < 0) // 左左情况
					t = rotateWithLeftChild(t);
				else // 左右情况
					t = doubleWithLeftChild(t);
			}
		} else if (compareResult > 0) {
			t.right = insert(x, t.right);
			if (height(t.right) - height(t.left) == 2) {
				if (myCompare(x, t.right.element) < 0) // 右左情况
					t = doubleWithRightChild(t);
				else // 右右情况
					t = rotateWithRightChild(t);
			}
		}
		// 完了之后更新height值
		t.height = Math.max(height(t.left), height(t.right)) + 1;
		return t;
	}

	private AvlNode<AnyType> remove(AnyType x, AvlNode<AnyType> t) {
		if (t == null)
			return null;
		int compareResult = myCompare(x, t.element);
		if (compareResult < 0) {
			t.left = remove(x, t.left);
			// 完了之后验证该子树是否平衡
			if (t.right != null) { // 若右子树为空，则一定是平衡的，此时左子树相当对父节点深度最多为1, 所以只考虑右子树非空情况
				if (t.left == null) { // 若左子树删除后为空，则需要判断右子树
					if (height(t.right) - t.height == 2) {
						AvlNode<AnyType> k = t.right;
						if (k.right != null) { // 右子树存在，按正常情况单旋转
							System.out.println(
									"-----------------------------------------------------------------------------11111");
							t = rotateWithRightChild(t);
						} else { // 否则是右左情况，双旋转
							System.out.println(
									"-----------------------------------------------------------------------------22222");
							t = doubleWithRightChild(t);
						}
					}
				} else { // 否则判断左右子树的高度差
					// 左子树自身也可能不平衡，故先平衡左子树，再考虑整体
					AvlNode<AnyType> k = t.left;
					// 删除操作默认用右子树上最小节点补删除的节点
					// k的左子树高度不低于k的右子树
					if (k.right != null) {
						if (height(k.left) - height(k.right) == 2) {
							AvlNode<AnyType> m = k.left;
							if (m.left != null) { // 左子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------33333");
								k = rotateWithLeftChild(k);
							} else { // 否则是左右情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------44444");
								k = doubleWithLeftChild(k);
							}
						}
					} else {
						if (height(k.left) - k.height == 2) {
							AvlNode<AnyType> m = k.left;
							if (m.left != null) { // 左子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------hhhhh");
								k = rotateWithLeftChild(k);
							} else { // 否则是左右情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------iiiii");
								k = doubleWithLeftChild(k);
							}
						}
					}
					if (height(t.right) - height(t.left) == 2) {
						// 右子树自身一定是平衡的，左右失衡的话单旋转可以解决问题
						System.out.println(
								"-----------------------------------------------------------------------------55555");
						t = rotateWithRightChild(t);
					}
				}
			}
			// 完了之后更新height值
			t.height = Math.max(height(t.left), height(t.right)) + 1;
		} else if (compareResult > 0) {
			t.right = remove(x, t.right);
			// 下面验证子树是否平衡
			if (t.left != null) { // 若左子树为空，则一定是平衡的，此时右子树相当对父节点深度最多为1
				if (t.right == null) { // 若右子树删除后为空，则只需判断左子树
					if (height(t.left) - t.height == 2) {
						AvlNode<AnyType> k = t.left;
						if (k.left != null) {
							System.out.println(
									"-----------------------------------------------------------------------------66666");
							t = rotateWithLeftChild(t);
						} else {
							System.out.println(
									"-----------------------------------------------------------------------------77777");
							t = doubleWithLeftChild(t);
						}
					}
				} else { // 若右子树删除后非空，则判断左右子树的高度差
					// 右子树自身也可能不平衡，故先平衡右子树，再考虑整体
					AvlNode<AnyType> k = t.right;
					// 删除操作默认用右子树上最小节点（靠左）补删除的节点
					// k的右子树高度不低于k的左子树
					if (k.left != null) {
						if (height(k.right) - height(k.left) == 2) {
							AvlNode<AnyType> m = k.right;
							if (m.right != null) { // 右子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------88888");
								k = rotateWithRightChild(k);
							} else { // 否则是右左情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------99999");
								k = doubleWithRightChild(k);
							}
						}
					} else {
						if (height(k.right) - k.height == 2) {
							AvlNode<AnyType> m = k.right;
							if (m.right != null) { // 右子树存在，按正常情况单旋转
								System.out.println(
										"-----------------------------------------------------------------------------aaaaa");
								k = rotateWithRightChild(k);
							} else { // 否则是右左情况，双旋转
								System.out.println(
										"-----------------------------------------------------------------------------bbbbb");
								k = doubleWithRightChild(k);
							}
						}
					}
					if (height(t.left) - height(t.right) == 2) {
						// 左子树自身一定是平衡的，左右失衡的话单旋转可以解决问题
						System.out.println(
								"-----------------------------------------------------------------------------ccccc");
						t = rotateWithLeftChild(t);
					}
				}
			}
			// 完了之后更新height值
			t.height = Math.max(height(t.left), height(t.right)) + 1;
		} else if (t.left != null && t.right != null) {
			// 默认用其右子树的最小数据代替该节点的数据并递归的删除那个节点
			t.element = findMin(t.right).element;
			t.right = remove(t.element, t.right);
			if (t.right == null) { // 若右子树删除后为空，则只需判断左子树与根的高度差
				if (height(t.left) - t.height == 2) {
					AvlNode<AnyType> k = t.left;
					if (k.left != null) {
						System.out.println(
								"-----------------------------------------------------------------------------ddddd");
						t = rotateWithLeftChild(t);
					} else {
						System.out.println(
								"-----------------------------------------------------------------------------eeeee");
						t = doubleWithLeftChild(t);
					}
				}
			} else { // 若右子树删除后非空，则判断左右子树的高度差
				// 右子树自身也可能不平衡，故先平衡右子树，再考虑整体
				AvlNode<AnyType> k = t.right;
				// 删除操作默认用右子树上最小节点（靠左）补删除的节点

				if (k.left != null) {
					if (height(k.right) - height(k.left) == 2) {
						AvlNode<AnyType> m = k.right;
						if (m.right != null) { // 右子树存在，按正常情况单旋转
							System.out.println(
									"-----------------------------------------------------------------------------fffff");
							k = rotateWithRightChild(k);
						} else { // 否则是右左情况，双旋转
							System.out.println(
									"-----------------------------------------------------------------------------ggggg");
							k = doubleWithRightChild(k);
						}
					}
				} else {
					if (height(k.right) - k.height == 2) {
						AvlNode<AnyType> m = k.right;
						if (m.right != null) { // 右子树存在，按正常情况单旋转
							System.out.println(
									"-----------------------------------------------------------------------------hhhhh");
							k = rotateWithRightChild(k);
						} else { // 否则是右左情况，双旋转
							System.out.println(
									"-----------------------------------------------------------------------------iiiii");
							k = doubleWithRightChild(k);
						}
					}
				}
				// 左子树自身一定是平衡的，左右失衡的话单旋转可以解决问题
				if (height(t.left) - height(t.right) == 2) {
					System.out.println(
							"-----------------------------------------------------------------------------jjjjj");
					t = rotateWithLeftChild(t);
				}
			}
			// 完了之后更新height值
			t.height = Math.max(height(t.left), height(t.right)) + 1;
		} else {
			System.out.println("-----------------------------------------------------------------------------kkkkk");
			t = (t.left != null) ? t.left : t.right;
		}
		return t;
	}

	// 左左情况单旋转
	private AvlNode<AnyType> rotateWithLeftChild(AvlNode<AnyType> k2) {
		AvlNode<AnyType> k1 = k2.left;
		k2.left = k1.right;
		k1.right = k2;
		k2.height = Math.max(height(k2.left), height(k2.right)) + 1;
		k1.height = Math.max(height(k1.left), k2.height) + 1;
		return k1; // 返回新的根
	}

	// 右右情况单旋转
	private AvlNode<AnyType> rotateWithRightChild(AvlNode<AnyType> k2) {
		AvlNode<AnyType> k1 = k2.right;
		k2.right = k1.left;
		k1.left = k2;
		k2.height = Math.max(height(k2.left), height(k2.right)) + 1;
		k1.height = Math.max(height(k1.right), k2.height) + 1;
		return k1; // 返回新的根
	}

	// 左右情况
	private AvlNode<AnyType> doubleWithLeftChild(AvlNode<AnyType> k3) {
		try {
			k3.left = rotateWithRightChild(k3.left);
		} catch (NullPointerException e) {
			System.out.println("k.left.right为：" + k3.left.right);
			throw e;
		}
		return rotateWithLeftChild(k3);
	}

	// 右左情况
	private AvlNode<AnyType> doubleWithRightChild(AvlNode<AnyType> k3) {
		try {
			k3.right = rotateWithLeftChild(k3.right);
		} catch (NullPointerException e) {
			System.out.println("k.right.left为：" + k3.right.left);
			throw e;
		}
		return rotateWithRightChild(k3);
	}
}




```

测试样例

```java
import java.util.Random;
import org.junit.Test;

public class AvlTreeTest {
	private AvlTree<Integer> avlTree = new AvlTree<Integer>();

	@Test
	public void testInsert() {
		avlTree.insert(100);
		avlTree.insert(120);
		avlTree.insert(300);
		avlTree.insert(500);
		avlTree.insert(111);
		avlTree.insert(92);
		avlTree.insert(77);
		avlTree.insert(125);
		System.out.println(avlTree.contains(120));
		avlTree.remove(120);
		avlTree.remove(125); // 需要单旋转
		System.out.println(avlTree.contains(120));
		avlTree.insert(78); // 需要双旋转
		System.out.println("Insert Success !");
	}

	@Test
	public void testRotate() {
		avlTree.insert(100);
		avlTree.insert(90);
		avlTree.insert(92);
		avlTree.insert(78);
		avlTree.insert(76);
		System.out.println("Insert Success !");
	}

	/**
	 * 通过较大数据进行测试，暂时还没有发现问题
	 */
	@Test
	public void testAll() {
		avlTree.makeEmpty();
		Random random = new Random();
		for (int i = 1; i <= 1000000; i++) {
			avlTree.insert(random.nextInt(1000000));
		}
		for (int i = 2000000; i >= 1000000; i--) {
			avlTree.insert(i);
		}
		/*
		 * for(int i=700000;i>=400000;i--){ avlTree.insert(i); } for(int
		 * i=100000;i<=200000;i++){ avlTree.insert(i); } for(int
		 * i=400000;i<=500000;i++){ avlTree.insert(random.nextInt(600000)); }
		 */
		for (int i = 200000; i < 1400000; i++) {
			int target = random.nextInt(1500000);
			if (avlTree.contains(target)) {
				avlTree.remove(target);
			}
		}
		System.out.println("Insert Success !");
	}
}
```

## 平衡查找树之红黑树

[红黑树(一)之 原理和算法详细介绍](https://www.cnblogs.com/skywang12345/p/3245399.html)

[红黑树(五)之 Java的实现](https://www.cnblogs.com/skywang12345/p/3624343.html)

[教你初步了解红黑树](https://blog.csdn.net/v_JULY_v/article/details/6105630)

**红黑树的定义：**红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为”对称二叉B树”，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。**它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。**

红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。





## B,B+,B*树

## LSM树

## Trie树

## 哈夫曼树

## KD树

