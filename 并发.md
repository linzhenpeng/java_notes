

[Java线程的6种状态及切换(透彻讲解)](https://blog.csdn.net/pange1991/article/details/53860651)

[Java多线程学习（吐血超详细总结）](https://blog.csdn.net/evankaka/article/details/44153709)

[Java并发编程与技术内幕:线程池深入理解](https://blog.csdn.net/evankaka/article/details/51489322)

[透彻理解Java并发编程(重点)](https://segmentfault.com/blog/ressmix_multithread)

java并发知识库

![1559629599677](F:\git\java_notes\images\并发\1559629599677.png)

## 基础原理

**进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）**

**线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）**





## 多线程

#### 实现方式

###### 继承Thread类

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方
法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线
程，并执行 run()方法。

```java
public class MyThread extends Thread {
public void run() {
System.out.println("MyThread.run()");
}
}
MyThread myThread1 = new MyThread();
myThread1.start();
```

###### 实现Runnable接口

如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个
Runnable 接口

```java
public class MyThread extends OtherClass implements Runnable {
public void run() {
System.out.println("MyThread.run()");
}
}
//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：
MyThread myThread = new MyThread();
Thread thread = new Thread(myThread);
thread.start();
```

实现Call

```java
public class ThreadTest {
	public static void main(String[] args) {
		MyTask mytask = new MyTask("1");
		FutureTask<Integer> task = new FutureTask<>(mytask);
		Thread thread = new Thread(task);
		thread.start();
		try {
			System.out.println("task1返回结果:" + task.get(10, TimeUnit.SECONDS));
		} catch (Exception e) {
			e.printStackTrace();
		} 
	}
}
class MyTask implements Callable<Integer> {
	private String name;
	public MyTask(String name) {
		this.name = name;
	}
	@Override
	public Integer call() throws Exception {
		System.out.println("task  " + name + "开始进行计算");
		Thread.sleep(3000);
		int sum = new Random().nextInt(300);
		int result = 0;
		for (int i = 0; i < sum; i++)
			result += i;
		return result;
	}
}
```





## 线程池



## 锁(同步锁,非同步锁,重入锁,乐观锁,悲观锁,分布锁)



## ThreadLocal(底层实现及风险)

## volatile

## CAS和AQS

## 并发工具

#### CountDownLatch 

#### CyclicBarrier

#### Semaphore

#### Executors

#### Exchanger

## Fork/join框架

## 原子类

## 并发容器

ConcurrentHashMap

CopyOnWriteList

SynchronizedList

ConcurrentQueue

LinkedBlockingQueue

DelayQueue

TransferQueue

SynchronusQueue 

## 线程安全的单例模式

## Immutable模式

## Future模式

## Per-Message模式

## Read-Write Lock模式

## Balking设计模式

## Guarded Suspension（保护性暂挂模式）

## Work Thread模式

## Two-Phase Termination Pattern两阶段终止模式

## Thread-Specific Storage(threadlocal) 线程独有的存储库模式



## 消费者-生产者模式

## 死锁





