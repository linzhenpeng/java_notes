

[Java线程的6种状态及切换(透彻讲解)](https://blog.csdn.net/pange1991/article/details/53860651)

[Java多线程学习（吐血超详细总结）](https://blog.csdn.net/evankaka/article/details/44153709)

[Java并发编程与技术内幕:线程池深入理解](https://blog.csdn.net/evankaka/article/details/51489322)

[透彻理解Java并发编程(重点)](https://segmentfault.com/blog/ressmix_multithread)

[Java 多线程知识小抄集 ( 一 )](http://www.importnew.com/27167.html)

[一篇文章，让你彻底弄懂生产者--消费者问题](https://www.jianshu.com/p/e29632593057)

[生产者-消费者模式的三种实现方式](https://www.cnblogs.com/fankongkong/p/7339848.html)

java并发知识库

![1559629599677](F:\git\java_notes\images\并发\1559629599677.png)

## 基础原理

**进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）**

**线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）**



## 多线程

#### 实现方式

###### 继承Thread类

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方
法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线
程，并执行 run()方法。

```java
public class MyThread extends Thread {
public void run() {
System.out.println("MyThread.run()");
}
}
MyThread myThread1 = new MyThread();
myThread1.start();
```

###### 实现Runnable接口

如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个
Runnable 接口

```java
public class MyThread extends OtherClass implements Runnable {
public void run() {
System.out.println("MyThread.run()");
}
}
//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：
MyThread myThread = new MyThread();
Thread thread = new Thread(myThread);
thread.start();
```

两种实现方式总结：

实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

4）：线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类

#### java 6种线程状态

1. **初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。

2. **运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
     线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。

3. **阻塞(BLOCKED)**：表示线程阻塞于锁。

4. **等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

5. **超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。

6. **终止(TERMINATED)**：表示该线程已经执行完毕。

     状态转移图1

![](F:\git\java_notes\images\并发\v2-20edff079dc147b795e08261be1161f4_r.jpg)

状态转移图2

![](F:\git\java_notes\images\并发\20181120173640764.jpeg)

1. **初始状态**
    实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。

2.1. **就绪状态**
就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。
调用线程的start()方法，此线程进入就绪状态。
当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。
当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。
锁池里的线程拿到对象锁后，进入就绪状态。
2.2. **运行中状态**
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

3. **阻塞状态**
    阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

4. **等待**
    处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

5. **超时等待**
    处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

6. **终止状态**
    当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。
    在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

注意网上说的5种状态是错的,Thread源码里面就明确了是6种状态:

```java
   public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```

#### 线程优先级和守护线程

https://www.cnblogs.com/xiaoxi/p/7133002.html?utm_source=itdadao&utm_medium=referral

**一、线程优先级的介绍**

  线程的优先级用数字来表示，默认范围是1到10，即Thread.MIN_PRIORITY到Thread.MAX_PRIORTY.一个线程的默认优先级是5，即Thread.NORM_PRIORTY

对优先级操作的方法：

int getPriority():得到线程的优先级

void setPriority(int newPriority):当线程被创建后，可通过此方法改变线程的优先级

必须指出的是：线程的优先级无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大。

​     java 中有两种线程：**用户线程**和**守护线程**。通过setDaemon(true) 可以设置用户线程为守护线程, 通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用于执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：**Java虚拟机在“用户线程”都结束后会后退出**。

守护线程是一种特殊的线程，它的特性有“陪伴”的含义，当进程中不存在非守护线程了，守护线程自动销毁。典型的守护线程是(GC)垃圾回收线程。

**JDK 中关于线程优先级和守护线程的介绍如下：**

​      每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。

​    当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：
​    (01) 调用了exit()方法，并且exit()有权限被正常执行。
​    (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。

​    每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。

例子:  线程1可能会出现没打印完  程序就退出的现象

```java
class MyThread implements Runnable {
	String name;
	public MyThread(String name) {
		super();
		this.name = name;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println(name + "---" + i);
		}
	}
}
public static void threadTest() {
		MyThread myThread1=new MyThread("t1");
		MyThread myThread2=new MyThread("t2");
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.setDaemon(true);
		t1.start();
		t2.start();
}
```

#### wait, notify, notifyAll用法(线程间协作)

注意这三个方法是对象的  不是Thread类的

只能在同步方法或者同步块中使用wait()方法。在执行wait()方法后，当前线程释放锁（这点与sleep和yield方法不同,sleep和yield 不释放锁）。调用了wait函数的线程会一直等待，知道有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立刻获得对象的锁，要等待执行notify()方法的线程执行完，即退出synchronized代码块后，当前线程才会释放锁，而呈wait状态的线程才可以获取该对象锁。

如果调用wait()方法时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕获异常。

notify方法只会（随机）唤醒一个正在等待的线程，而notifyAll方法会唤醒所有正在等待的线程。如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。

详细可以参考《[JAVA线程间协作：wait.notify.notifyAll](http://blog.csdn.net/u013256816/article/details/50440123)》

带参数的wait(long timeout)或者wait(long timeout, int nanos)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。

**wait方法**

调用线程的sleep，yield方法时，线程并不会让出对象锁，wait却不同。

wait函数必须在同步代码块中调用(也就是当前线程必须持有对象的锁)，他的功能是这样的：

我累了，休息一会儿，对象的锁你们拿去用吧，CPU也给你们。

调用了wait函数的线程会一直等待，直到有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立即获得对象的锁。也就是说，一个线程调用了对象的wait方法后，他需要等待两件事情的发生：

1. 有其他线程调用同一个对象的notify或者notifyAll方法（调用notify/notifyAll方法之前）

2. 被唤醒之后重新获得对象的锁(调用notify/notifyAll方法之后)才能继续往下执行后续动作。

如果一个线程调用了某个对象的wait方法，但是后续并没有其他线程调用该对象的notify或者notifyAll方法，则该线程将会永远等下去…

**notify和notifyAll方法**

notify/notifyAll方法也必须在**同步代码块中**调用(也就是调用线程必须持有对象的锁)，他们的功能是这样的：

女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。

不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁。

如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。



例子让两线程交替打印1-100:

```java
	
public static void threadTest() {
		Object o=new Object();
		MyThread myThread1=new MyThread("t1",o);
		MyThread myThread2=new MyThread("t2",o);
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.start();
		t2.start();
}
	
class MyThread implements Runnable {
	String name;
	Object o;
	public MyThread(String name,Object o) {
		super();
		this.name = name;
		this.o=o;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			synchronized (o) {
				System.out.println(name + "---" + i);
				o.notify();
				try {
					o.wait();//唤醒另外一个线程后 就进入等待 
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
```

例子 使用wait/notify 设计 生成者-消费者模式:

```java
class ProducerThread implements Runnable {
	List<String> list;
	int max;
	public ProducerThread(int max,List<String> list) {
		super();
		this.list = list;
		this.max=max;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			synchronized (list) {
				while (list.size() >= max) {
					try {
						System.out.println("仓库满了等等再生产");
						list.wait();
						System.out.println("仓库不满要再生产");
					} catch (Exception e) {
						// TODO: handle exception
					}
				}
				System.out.println("生产了-----" + i);
				list.add("" + i);
				list.notify();
			}
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
class ConsumerThread implements Runnable {
	List<String> list;
	public ConsumerThread(List<String> list) {
		super();
		this.list = list;
	}
	@Override
	public void run() {
		while (true) {
			synchronized (list) {
				while (list.size() == 0) {
					try {
						System.out.println("仓库空了");
						list.wait();
						System.out.println("仓库有货了");
					} catch (Exception e) {
						// TODO: handle exception
					}
				}
				String i = list.remove(0);
				System.out.println("消费了-----" + i);
				list.notify();
			}

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}
}

public static void producerAndConsumerTest() {
		List<String> list=new ArrayList<>();
		ProducerThread myThread1=new ProducerThread(50,list);
		ConsumerThread myThread2=new ConsumerThread(list);
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.start();
		t2.start();
}
```

#### **sleep**

Java中线程的暂停是调用`java.lang.Thread`类的`sleep`方法（注意是**类方法**）。该方法会使**当前正在执行的线程**暂停指定的时间，如果线程持有锁，`sleep`方法结束前并不会释放该锁。

```java
 try {
                Thread.sleep(1000);    //当前main线程暂停1000ms
            } catch (InterruptedException e) {
}
```

*上述代码中，当main线程调用Thread.sleep(1000)后，线程会被暂停，如果被interrupt，则会抛出InterruptedException异常。*

#### join

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。join与synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是“对象监视器”做为同步。
join提供了另外两种实现方法：join(long millis)和join(long millis, int nanos)，至多等待多长时间而退出等待(释放锁)，退出等待之后还可以继续运行。内部是通过wait方法来实现的。

```java
System.out.println("method main begin-----");
Thread t = new Thread(new Runnable(){
    int i = 0;
    @Override
    public void run()
    {
        while(true)
        {
            System.out.println(i++);
            try
            {
                TimeUnit.MILLISECONDS.sleep(100);
            }
            catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }
    }
});
t.start();
t.join(2000);
System.out.println("method main end-----");
```

输出:

```
method main begin-----
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
method main end-----
19
20
21
```

#### **yield**

 Thread.yield()方法作用是：暂停当前正在执行的线程对象，和其它线程重新争夺cpu。
yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。

#### **interrupt**

Thread.interrupt()作用是中断本线程。
本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。
如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。
如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。
如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。
中断一个“已终止的线程”不会产生任何操作。

#### **interrupted() 和 isInterrupted()的区别**

interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。
区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。



#### 比较和注意

Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！

上面中wait,notify和notifyAll 是Object的方法 其余的是Thread的方法 

wait 会释放锁  sleep,join,yield 都不会释放锁   

sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行

wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 
   如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。

**isAlive(): 判断一个线程是否存活。** 

**activeCount(): 程序中活跃的线程数。 　　**

**enumerate(): 枚举程序中的线程。    **

**currentThread(): 得到当前线程。**

## Callable接口











## 锁(同步锁,非同步锁,重入锁,乐观锁,悲观锁,分布锁,锁降级)



## 线程池



## ThreadLocal(底层实现及风险)

## volatile

## CAS和AQS

## 并发工具

#### CountDownLatch 

#### CyclicBarrier

#### Semaphore

#### Executors

#### Exchanger

## Fork/join框架

## 原子类

## 并发容器

ConcurrentHashMap

CopyOnWriteList

SynchronizedList

ConcurrentQueue

LinkedBlockingQueue

DelayQueue

TransferQueue

SynchronusQueue 

## 线程安全的单例模式

## Immutable模式

## Future模式

## Per-Message模式

## Read-Write Lock模式

## Balking设计模式
## Guarded Suspension（保护性暂挂模式）
## Work Thread模式
## Two-Phase Termination Pattern两阶段终止模式
## Thread-Specific Storage(threadlocal) 线程独有的存储库模式
## 消费者-生产者模式

## 死锁