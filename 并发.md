

[Java线程的6种状态及切换(透彻讲解)](https://blog.csdn.net/pange1991/article/details/53860651)

[Java多线程学习（吐血超详细总结）](https://blog.csdn.net/evankaka/article/details/44153709)

[Java并发编程与技术内幕:线程池深入理解](https://blog.csdn.net/evankaka/article/details/51489322)

[透彻理解Java并发编程(重点)](https://segmentfault.com/blog/ressmix_multithread)

[Java 多线程知识小抄集 ( 一 )](http://www.importnew.com/27167.html)

[一篇文章，让你彻底弄懂生产者--消费者问题](https://www.jianshu.com/p/e29632593057)

[生产者-消费者模式的三种实现方式](https://www.cnblogs.com/fankongkong/p/7339848.html)

java并发知识库

![1559629599677](F:\git\java_notes\images\并发\1559629599677.png)

## 基础原理

**进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）**

**线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）**



## 多线程

#### 实现方式

###### 继承Thread类

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方
法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线
程，并执行 run()方法。

```java
public class MyThread extends Thread {
public void run() {
System.out.println("MyThread.run()");
}
}
MyThread myThread1 = new MyThread();
myThread1.start();
```

###### 实现Runnable接口

如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个
Runnable 接口

```java
public class MyThread extends OtherClass implements Runnable {
public void run() {
System.out.println("MyThread.run()");
}
}
//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：
MyThread myThread = new MyThread();
Thread thread = new Thread(myThread);
thread.start();
```

两种实现方式总结：

实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

4）：线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类

#### java 6种线程状态

1. **初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。

2. **运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
     线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。

3. **阻塞(BLOCKED)**：表示线程阻塞于锁。

4. **等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

5. **超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。

6. **终止(TERMINATED)**：表示该线程已经执行完毕。

     状态转移图1

![](F:\git\java_notes\images\并发\v2-20edff079dc147b795e08261be1161f4_r.jpg)

状态转移图2

![](F:\git\java_notes\images\并发\20181120173640764.jpeg)

1. **初始状态**
    实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。

2.1. **就绪状态**
就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。
调用线程的start()方法，此线程进入就绪状态。
当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。
当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。
锁池里的线程拿到对象锁后，进入就绪状态。
2.2. **运行中状态**
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

3. **阻塞状态**
    阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

4. **等待**
    处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

5. **超时等待**
    处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

6. **终止状态**
    当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。
    在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

注意网上说的5种状态是错的,Thread源码里面就明确了是6种状态:

```java
   public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```

#### 线程优先级和守护线程

https://www.cnblogs.com/xiaoxi/p/7133002.html?utm_source=itdadao&utm_medium=referral

**一、线程优先级的介绍**

  线程的优先级用数字来表示，默认范围是1到10，即Thread.MIN_PRIORITY到Thread.MAX_PRIORTY.一个线程的默认优先级是5，即Thread.NORM_PRIORTY

对优先级操作的方法：

int getPriority():得到线程的优先级

void setPriority(int newPriority):当线程被创建后，可通过此方法改变线程的优先级

必须指出的是：线程的优先级无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大。

​     java 中有两种线程：**用户线程**和**守护线程**。通过setDaemon(true) 可以设置用户线程为守护线程, 通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用于执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：**Java虚拟机在“用户线程”都结束后会后退出**。

守护线程是一种特殊的线程，它的特性有“陪伴”的含义，当进程中不存在非守护线程了，守护线程自动销毁。典型的守护线程是(GC)垃圾回收线程。

**JDK 中关于线程优先级和守护线程的介绍如下：**

​      每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。

​    当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：
​    (01) 调用了exit()方法，并且exit()有权限被正常执行。
​    (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。

​    每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。

例子:  线程1可能会出现没打印完  程序就退出的现象

```java
class MyThread implements Runnable {
	String name;
	public MyThread(String name) {
		super();
		this.name = name;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println(name + "---" + i);
		}
	}
}
public static void threadTest() {
		MyThread myThread1=new MyThread("t1");
		MyThread myThread2=new MyThread("t2");
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.setDaemon(true);
		t1.start();
		t2.start();
}
```

#### wait, notify, notifyAll用法(线程间协作)

注意这三个方法是对象的  不是Thread类的

只能在同步方法或者同步块中使用wait()方法。在执行wait()方法后，当前线程释放锁（这点与sleep和yield方法不同,sleep和yield 不释放锁）。调用了wait函数的线程会一直等待，知道有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立刻获得对象的锁，要等待执行notify()方法的线程执行完，即退出synchronized代码块后，当前线程才会释放锁，而呈wait状态的线程才可以获取该对象锁。

如果调用wait()方法时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕获异常。

notify方法只会（随机）唤醒一个正在等待的线程，而notifyAll方法会唤醒所有正在等待的线程。如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。

详细可以参考《[JAVA线程间协作：wait.notify.notifyAll](http://blog.csdn.net/u013256816/article/details/50440123)》

带参数的wait(long timeout)或者wait(long timeout, int nanos)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。

**wait方法**

调用线程的sleep，yield方法时，线程并不会让出对象锁，wait却不同。

wait函数必须在同步代码块中调用(也就是当前线程必须持有对象的锁)，他的功能是这样的：

我累了，休息一会儿，对象的锁你们拿去用吧，CPU也给你们。

调用了wait函数的线程会一直等待，直到有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立即获得对象的锁。也就是说，一个线程调用了对象的wait方法后，他需要等待两件事情的发生：

1. 有其他线程调用同一个对象的notify或者notifyAll方法（调用notify/notifyAll方法之前）

2. 被唤醒之后重新获得对象的锁(调用notify/notifyAll方法之后)才能继续往下执行后续动作。

如果一个线程调用了某个对象的wait方法，但是后续并没有其他线程调用该对象的notify或者notifyAll方法，则该线程将会永远等下去…

**notify和notifyAll方法**

notify/notifyAll方法也必须在**同步代码块中**调用(也就是调用线程必须持有对象的锁)，他们的功能是这样的：

女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。

不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁。

如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。



例子让两线程交替打印1-100:

```java
	
public static void threadTest() {
		Object o=new Object();
		MyThread myThread1=new MyThread("t1",o);
		MyThread myThread2=new MyThread("t2",o);
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.start();
		t2.start();
}
	
class MyThread implements Runnable {
	String name;
	Object o;
	public MyThread(String name,Object o) {
		super();
		this.name = name;
		this.o=o;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			synchronized (o) {
				System.out.println(name + "---" + i);
				o.notify();
				try {
					o.wait();//唤醒另外一个线程后 就进入等待 
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
```

例子 使用wait/notify 设计 生成者-消费者模式:

```java
class ProducerThread implements Runnable {
	List<String> list;
	int max;
	public ProducerThread(int max,List<String> list) {
		super();
		this.list = list;
		this.max=max;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			synchronized (list) {
				while (list.size() >= max) {
					try {
						System.out.println("仓库满了等等再生产");
						list.wait();
						System.out.println("仓库不满要再生产");
					} catch (Exception e) {
						// TODO: handle exception
					}
				}
				System.out.println("生产了-----" + i);
				list.add("" + i);
				list.notify();
			}
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
class ConsumerThread implements Runnable {
	List<String> list;
	public ConsumerThread(List<String> list) {
		super();
		this.list = list;
	}
	@Override
	public void run() {
		while (true) {
			synchronized (list) {
				while (list.size() == 0) {
					try {
						System.out.println("仓库空了");
						list.wait();
						System.out.println("仓库有货了");
					} catch (Exception e) {
						// TODO: handle exception
					}
				}
				String i = list.remove(0);
				System.out.println("消费了-----" + i);
				list.notify();
			}

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}
}

public static void producerAndConsumerTest() {
		List<String> list=new ArrayList<>();
		ProducerThread myThread1=new ProducerThread(50,list);
		ConsumerThread myThread2=new ConsumerThread(list);
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.start();
		t2.start();
}
```

#### **sleep**

Java中线程的暂停是调用`java.lang.Thread`类的`sleep`方法（注意是**类方法**）。该方法会使**当前正在执行的线程**暂停指定的时间，如果线程持有锁，`sleep`方法结束前并不会释放该锁。

```java
 try {
                Thread.sleep(1000);    //当前main线程暂停1000ms
            } catch (InterruptedException e) {
}
```

*上述代码中，当main线程调用Thread.sleep(1000)后，线程会被暂停，如果被interrupt，则会抛出InterruptedException异常。*

#### join

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。join与synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是“对象监视器”做为同步。
join提供了另外两种实现方法：join(long millis)和join(long millis, int nanos)，至多等待多长时间而退出等待(释放锁)，退出等待之后还可以继续运行。内部是通过wait方法来实现的。

```java
System.out.println("method main begin-----");
Thread t = new Thread(new Runnable(){
    int i = 0;
    @Override
    public void run()
    {
        while(true)
        {
            System.out.println(i++);
            try
            {
                TimeUnit.MILLISECONDS.sleep(100);
            }
            catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }
    }
});
t.start();
t.join(2000);
System.out.println("method main end-----");
```

输出:

```
method main begin-----
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
method main end-----
19
20
21
```

#### **yield**







#### **interrupt**



#### 比较



## Callable接口



## 锁(同步锁,非同步锁,重入锁,乐观锁,悲观锁,分布锁,锁降级)



## 线程池



## ThreadLocal(底层实现及风险)

## volatile

## CAS和AQS

## 并发工具

#### CountDownLatch 

#### CyclicBarrier

#### Semaphore

#### Executors

#### Exchanger

## Fork/join框架

## 原子类

## 并发容器

ConcurrentHashMap

CopyOnWriteList

SynchronizedList

ConcurrentQueue

LinkedBlockingQueue

DelayQueue

TransferQueue

SynchronusQueue 

## 线程安全的单例模式

## Immutable模式

## Future模式

## Per-Message模式

## Read-Write Lock模式

## Balking设计模式
## Guarded Suspension（保护性暂挂模式）
## Work Thread模式
## Two-Phase Termination Pattern两阶段终止模式
## Thread-Specific Storage(threadlocal) 线程独有的存储库模式
## 消费者-生产者模式

## 死锁