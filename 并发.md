

[Java线程的6种状态及切换(透彻讲解)](https://blog.csdn.net/pange1991/article/details/53860651)

[Java多线程学习（吐血超详细总结）](https://blog.csdn.net/evankaka/article/details/44153709)

[Java并发编程与技术内幕:线程池深入理解](https://blog.csdn.net/evankaka/article/details/51489322)

[透彻理解Java并发编程(重点)](https://segmentfault.com/blog/ressmix_multithread)

[Java 多线程知识小抄集 ( 一 )](http://www.importnew.com/27167.html)

[一篇文章，让你彻底弄懂生产者--消费者问题](https://www.jianshu.com/p/e29632593057)

[生产者-消费者模式的三种实现方式](https://www.cnblogs.com/fankongkong/p/7339848.html)

java并发知识库

![1559629599677](F:\git\java_notes\images\并发\1559629599677.png)

## 基础原理

**进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）**

**线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）**



## 多线程

#### 实现方式

###### 继承Thread类

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方
法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线
程，并执行 run()方法。

```java
public class MyThread extends Thread {
public void run() {
System.out.println("MyThread.run()");
}
}
MyThread myThread1 = new MyThread();
myThread1.start();
```

###### 实现Runnable接口

如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个
Runnable 接口

```java
public class MyThread extends OtherClass implements Runnable {
public void run() {
System.out.println("MyThread.run()");
}
}
//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：
MyThread myThread = new MyThread();
Thread thread = new Thread(myThread);
thread.start();
```

两种实现方式总结：

实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

4）：线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类

#### java 6种线程状态

1. **初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。

2. **运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
     线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。

3. **阻塞(BLOCKED)**：表示线程阻塞于锁。

4. **等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

5. **超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。

6. **终止(TERMINATED)**：表示该线程已经执行完毕。

     状态转移图1

![](F:\git\java_notes\images\并发\v2-20edff079dc147b795e08261be1161f4_r.jpg)

状态转移图2

![](F:\git\java_notes\images\并发\20181120173640764.jpeg)

1. **初始状态**
    实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。

2.1. **就绪状态**
就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。
调用线程的start()方法，此线程进入就绪状态。
当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。
当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。
锁池里的线程拿到对象锁后，进入就绪状态。
2.2. **运行中状态**
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

3. **阻塞状态**
    阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

4. **等待**
    处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

5. **超时等待**
    处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

6. **终止状态**
    当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。
    在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

注意网上说的5种状态是错的,Thread源码里面就明确了是6种状态:

```java
   public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```

#### 线程优先级和守护线程

https://www.cnblogs.com/xiaoxi/p/7133002.html?utm_source=itdadao&utm_medium=referral

**一、线程优先级的介绍**

  线程的优先级用数字来表示，默认范围是1到10，即Thread.MIN_PRIORITY到Thread.MAX_PRIORTY.一个线程的默认优先级是5，即Thread.NORM_PRIORTY

对优先级操作的方法：

int getPriority():得到线程的优先级

void setPriority(int newPriority):当线程被创建后，可通过此方法改变线程的优先级

必须指出的是：线程的优先级无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大。

​     java 中有两种线程：**用户线程**和**守护线程**。通过setDaemon(true) 可以设置用户线程为守护线程, 通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用于执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：**Java虚拟机在“用户线程”都结束后会后退出**。

守护线程是一种特殊的线程，它的特性有“陪伴”的含义，当进程中不存在非守护线程了，守护线程自动销毁。典型的守护线程是(GC)垃圾回收线程。

**JDK 中关于线程优先级和守护线程的介绍如下：**

​      每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。

​    当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：
​    (01) 调用了exit()方法，并且exit()有权限被正常执行。
​    (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。

​    每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。

例子:  线程1可能会出现没打印完  程序就退出的现象

```java
class MyThread implements Runnable {
	String name;
	public MyThread(String name) {
		super();
		this.name = name;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println(name + "---" + i);
		}
	}
}
public static void threadTest() {
		MyThread myThread1=new MyThread("t1");
		MyThread myThread2=new MyThread("t2");
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.setDaemon(true);
		t1.start();
		t2.start();
}
```

#### wait, notify, notifyAll用法(线程间协作)

注意这三个方法是对象的  不是Thread类的

只能在同步方法或者同步块中使用wait()方法。在执行wait()方法后，当前线程释放锁（这点与sleep和yield方法不同,sleep和yield 不释放锁）。调用了wait函数的线程会一直等待，知道有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立刻获得对象的锁，要等待执行notify()方法的线程执行完，即退出synchronized代码块后，当前线程才会释放锁，而呈wait状态的线程才可以获取该对象锁。

如果调用wait()方法时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕获异常。

notify方法只会（随机）唤醒一个正在等待的线程，而notifyAll方法会唤醒所有正在等待的线程。如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。

详细可以参考《[JAVA线程间协作：wait.notify.notifyAll](http://blog.csdn.net/u013256816/article/details/50440123)》

带参数的wait(long timeout)或者wait(long timeout, int nanos)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。

**wait方法**

调用线程的sleep，yield方法时，线程并不会让出对象锁，wait却不同。

wait函数必须在同步代码块中调用(也就是当前线程必须持有对象的锁)，他的功能是这样的：

我累了，休息一会儿，对象的锁你们拿去用吧，CPU也给你们。

调用了wait函数的线程会一直等待，直到有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立即获得对象的锁。也就是说，一个线程调用了对象的wait方法后，他需要等待两件事情的发生：

1. 有其他线程调用同一个对象的notify或者notifyAll方法（调用notify/notifyAll方法之前）

2. 被唤醒之后重新获得对象的锁(调用notify/notifyAll方法之后)才能继续往下执行后续动作。

如果一个线程调用了某个对象的wait方法，但是后续并没有其他线程调用该对象的notify或者notifyAll方法，则该线程将会永远等下去…

**notify和notifyAll方法**

notify/notifyAll方法也必须在**同步代码块中**调用(也就是调用线程必须持有对象的锁)，他们的功能是这样的：

女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。

不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁。

如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。



例子让两线程交替打印1-100:

```java
	
public static void threadTest() {
		Object o=new Object();
		MyThread myThread1=new MyThread("t1",o);
		MyThread myThread2=new MyThread("t2",o);
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.start();
		t2.start();
}
	
class MyThread implements Runnable {
	String name;
	Object o;
	public MyThread(String name,Object o) {
		super();
		this.name = name;
		this.o=o;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			synchronized (o) {
				System.out.println(name + "---" + i);
				o.notify();
				try {
					o.wait();//唤醒另外一个线程后 就进入等待 
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
```

例子 使用wait/notify 设计 生成者-消费者模式:

```java
class ProducerThread implements Runnable {
	List<String> list;
	int max;
	public ProducerThread(int max,List<String> list) {
		super();
		this.list = list;
		this.max=max;
	}
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			synchronized (list) {
				while (list.size() >= max) {
					try {
						System.out.println("仓库满了等等再生产");
						list.wait();
						System.out.println("仓库不满要再生产");
					} catch (Exception e) {
						// TODO: handle exception
					}
				}
				System.out.println("生产了-----" + i);
				list.add("" + i);
				list.notify();
			}
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
class ConsumerThread implements Runnable {
	List<String> list;
	public ConsumerThread(List<String> list) {
		super();
		this.list = list;
	}
	@Override
	public void run() {
		while (true) {
			synchronized (list) {
				while (list.size() == 0) {
					try {
						System.out.println("仓库空了");
						list.wait();
						System.out.println("仓库有货了");
					} catch (Exception e) {
						// TODO: handle exception
					}
				}
				String i = list.remove(0);
				System.out.println("消费了-----" + i);
				list.notify();
			}

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}
}

public static void producerAndConsumerTest() {
		List<String> list=new ArrayList<>();
		ProducerThread myThread1=new ProducerThread(50,list);
		ConsumerThread myThread2=new ConsumerThread(list);
		Thread t1=new Thread(myThread1);
		Thread t2=new Thread(myThread2);
		t1.start();
		t2.start();
}
```

#### **sleep**

Java中线程的暂停是调用`java.lang.Thread`类的`sleep`方法（注意是**类方法**）。该方法会使**当前正在执行的线程**暂停指定的时间，如果线程持有锁，`sleep`方法结束前并不会释放该锁。

```java
 try {
                Thread.sleep(1000);    //当前main线程暂停1000ms
            } catch (InterruptedException e) {
}
```

*上述代码中，当main线程调用Thread.sleep(1000)后，线程会被暂停，如果被interrupt，则会抛出InterruptedException异常。*

#### join

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。join与synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是“对象监视器”做为同步。
join提供了另外两种实现方法：join(long millis)和join(long millis, int nanos)，至多等待多长时间而退出等待(释放锁)，退出等待之后还可以继续运行。内部是通过wait方法来实现的。

```java
System.out.println("method main begin-----");
Thread t = new Thread(new Runnable(){
    int i = 0;
    @Override
    public void run()
    {
        while(true)
        {
            System.out.println(i++);
            try
            {
                TimeUnit.MILLISECONDS.sleep(100);
            }
            catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }
    }
});
t.start();
t.join(2000);
System.out.println("method main end-----");
```

输出:

```
method main begin-----
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
method main end-----
19
20
21
```

#### **yield**

 Thread.yield()方法作用是：暂停当前正在执行的线程对象，和其它线程重新争夺cpu。
yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。

#### **interrupt**

Thread.interrupt()作用是中断本线程。
本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。
如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。
如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。
如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。
中断一个“已终止的线程”不会产生任何操作。

#### **interrupted() 和 isInterrupted()的区别**

interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。
区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。



#### 比较和注意

Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！

上面中wait,notify和notifyAll 是Object的方法 其余的是Thread的方法 

wait 会释放锁  sleep,join,yield 都不会释放锁   

sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行

wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 
   如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。

**isAlive(): 判断一个线程是否存活。** 

**activeCount(): 程序中活跃的线程数。 　　**

**enumerate(): 枚举程序中的线程。    **

**currentThread(): 得到当前线程。**

## Callable接口

上面介绍了线程的两种实现方式 一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。

如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。

下面来讨论一下Callable、Future和FutureTask三个类的使用方法。

Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：

```java
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。

　　那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：

```java
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
```

第一个submit方法里面的参数类型就是Callable。

暂时只需要知道Callable一般是和ExecutorService配合来使用的，具体的使用方法讲在后面讲述。

一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。

Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

Future类位于java.util.concurrent包下，它是一个接口：

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

在Future接口中声明了5个方法，下面依次解释每个方法的作用：

- cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。
- isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。
- isDone方法表示任务是否已经完成，若任务完成，则返回true；
- get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；
- get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。

　　也就是说Future提供了三种功能：

　　1）判断任务是否完成；

　　2）能够中断任务；

　　3）能够获取任务执行结果。

　　因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。

FutureTask

FutureTask的实现：

```java
public class FutureTask<V> implements RunnableFuture<V>
```

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。

　　FutureTask提供了2个构造器：

```java
`public` `FutureTask(Callable<V> callable) {``}``public` `FutureTask(Runnable runnable, V result) {``}`
```

　　事实上，FutureTask是Future接口的一个唯一实现类。

1.使用线程池+Callable+Future获取执行结果

```java
public class Test {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        Future<Integer> result = executor.submit(task);
        executor.shutdown();
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println("主线程在执行任务");
         
        try {
            System.out.println("task运行结果"+result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println("所有任务执行完毕");
    }
}
class Task implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println("子线程在进行计算");
        Thread.sleep(3000);
        int sum = 0;
        for(int i=0;i<100;i++)
            sum += i;
        return sum;
    }
}
```

　2.使用Callable+FutureTask获取执行结果

```java
public class Test {
    public static void main(String[] args) {
        //第一种方式
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        FutureTask<Integer> futureTask = new FutureTask<Integer>(task);
        executor.submit(futureTask);
        executor.shutdown();
         
        //第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread
        /*Task task = new Task();
        FutureTask<Integer> futureTask = new FutureTask<Integer>(task);
        Thread thread = new Thread(futureTask);
        thread.start();*/
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println("主线程在执行任务");
         
        try {
            System.out.println("task运行结果"+futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println("所有任务执行完毕");
    }
}
class Task implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println("子线程在进行计算");
        Thread.sleep(3000);
        int sum = 0;
        for(int i=0;i<100;i++)
            sum += i;
        return sum;
    }
}
```

## 锁(同步锁,非同步锁,重入锁,读写锁,乐观锁,悲观锁,分布锁,锁降级)

#### synchronized

synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。

锁机制有如下两种特性：

- 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。
- 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。

###### 1. 实例对象锁

在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。

###### 2. 类对象锁(全局锁)

在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过**对象锁**实现的，即**类的 Class 对象锁**。每个类只有一个 Class 对象，所以每个类只有一个类锁。



首先我们明确一点，`synchronized` 锁的不是代码，锁的都是**对象**。

锁的对象有以下几种：

**同步非静态方法**（`synchronized method`），锁是当前对象的**实例对象**。

**同步静态方法**（`synchronized static method`），锁是当前对象的**类对象（Class 对象）**。

**同步代码块一**（`synchronized (this)`，`synchronized (类实例对象)`），锁是小括号 `()` 中的**实例对象**。

**同步代码块二**（`synchronized (类.class)`），锁是小括号 `()` 中的**类对象（Class 对象）**。



使用锁时需要注意的问题:

[Java 8 并发篇 - 冷静分析 Synchronized（上）](https://zhuanlan.zhihu.com/p/34537635)

###### Synchronized与String锁

- **隐患：**由于在JVM中具有String常量池缓存的功能，因此**相同字面量是同一个锁！！！**

- **注意：**严重不推荐将String作为锁对象，而应该改用其他非缓存对象

- **提示：**对字面量有疑问的话请先回顾一下String的基础，这里不加以解释

  ```java
  public static void main(String[] args) {
      SynchronizedDemo synDemo = new SynchronizedDemo();
      Thread thread1 = new Thread(() -> synDemo.stringMethod("sally"));
      Thread thread2 = new Thread(() -> synDemo.stringMethod("sally"));
      thread1.start();
      thread2.start();
  }
  ---------------------
  //输出：
  Thread-0
  Thread-0
  Thread-0
  Thread-0
  ...死循环...
  //分析：输出结果永远都是Thread-0的死循环，也就是说另一个线程，即Thread-1线程根本不会运行
  //原因：同步块中的锁是同一个字面量
  ```

  String 缓存测试  

  ```java
  		String  s1="ddd"; // 会直接放到常量池中 
  		String s2=new String("ddd");
  		if(s1==s2) {   //false
  			System.out.println("true");
  		}else {
  			System.out.println("false");
  		}
  		
  		s2=s2.intern();  //intern 会先到字符串常量池中查找有没有该字符串如果有就返回,如果没有就把 该值放到常量池中再 返回  
  		
  		if(s1==s2) { //true
  			System.out.println("true");
  		}else {
  			System.out.println("false");
  		}
  		
  ```

  

  ###### Synchronized与不可变锁

  - **隐患：**当使用不可变类对象(final Class)作为对象锁时，使用synchronized同样会有并发问题
  - **原因：**由于不可变特性，当作为锁但同步块内部仍然有计算操作，会生成一个新的锁对象
  - **注意：**严重不推荐将final Class作为锁对象时仍对其有计算操作
  - **补充：**虽然String也是final Class，但它的原因却是字面量常量池 如果对String进行修改也会出现上面同样的问题

  ```java
  public class SynchronizedDemo {
      static Integer i = 0;   //Integer是final Class
      public static void main(String[] args) throws InterruptedException {
          Runnable runnable = new Runnable() {
              @Override
              public void run() {
                  for (int j = 0;j<10000;j++){
                      synchronized (i){
                          i++;
                      }
                  }
              }
          };
          Thread thread1 = new Thread(runnable);
          Thread thread2 = new Thread(runnable);
          thread1.start();
          thread2.start();
          thread1.join();
          thread2.join();
          System.out.println(i);
      }
  }
  ---------------------
  //输出：
  14134
  //分析：跟预想中的20000不一致，当使用Integer作为对象锁时但还有计算操作就会出现并发问题
  ```

  我们通过反编译发现执行i++操作相当于执行了i = Integer.valueOf(i.intValue()+1)

  通过查看Integer的valueOf方法实现可知，其每次都new了一个新的Integer对象，锁变了有木有！！！

  ```java
  public static Integer valueOf(int i) {
      if (i >= IntegerCache.low && i <= IntegerCache.high)
          return IntegerCache.cache[i + (-IntegerCache.low)];
      return new Integer(i);  //每次都new一个新的锁有木有！！！
  }
  ```

同步非静态方法

```java
class LockTest {

	public synchronized void synMethod() {
		String name = Thread.currentThread().getName();
		System.out.println(name + "访问synMethod");
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

public  static  void lockTest() {
		LockTest lockTest=new LockTest();
		Thread t1=new Thread(()->lockTest.synMethod());
		Thread t2=new Thread(()->lockTest.synMethod());
		t1.start();
		t2.start();
}
```

非静态方法锁的是对象实例 当线程2进去后会等待 线程1 执行完释放









#### lock和ReentrantLock

#### Condition

#### LockSupport

#### ReadWriteLock和ReentrantReadWriteLock

#### StampedLock







## volatile

## CAS和AQS(cas1.8改进)

## 原子类



## ThreadLocal(底层实现及风险)

## ThreadGroup

## 线程池

## 并发工具

#### CountDownLatch 

#### CyclicBarrier

#### Semaphore

#### Executors

#### Exchanger

#### Phaser

#### TimeUnit

## Fork/join框架

## 并发容器

由于内容较多,所以单独一个文件记录

## 线程安全的单例模式

## Immutable模式

## Future模式

## Per-Message模式

## Read-Write Lock模式

## Balking设计模式
## Guarded Suspension（保护性暂挂模式）
## Work Thread模式
## Two-Phase Termination Pattern两阶段终止模式
## Thread-Specific Storage(threadlocal) 线程独有的存储库模式
## 消费者-生产者模式

## 死锁